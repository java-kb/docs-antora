= Hibernate

== dependencies
The hibernate-entitymanager module includes transitive dependencies on other
modules we’ll need, such as hibernate-core and the JPA interface stubs.
[tabs]
====
Maven::
+
[source, xml]
----
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-entitymanager</artifactId>
            <version>5.6.9.Final</version>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>5.8.2</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <version>42.6.0</version>
        </dependency>
----

Gradle::
+
[source, gradle]
----
----
====

== Configuring a persistence unit
The standard configuration file for persistence units is located on the classpath in
META-INF/persistence.xml. Create the following configuration file for your application.
[source,xml,attributes]
----
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"
             version="2.0">

    <persistence-unit name="java-db-hibernate-tutorial01-default"> <1>
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>  <2>

        <properties>
            <property name="javax.persistence.jdbc.driver" value="org.postgresql.Driver"/>  <3>
            <property name="javax.persistence.jdbc.url" value="jdbc:postgresql://localhost:5432/test-hibernate"/>  <4>
            <property name="javax.persistence.jdbc.user" value="root"/>  <5>
            <property name="javax.persistence.jdbc.password" value=""/>  <6>

            <property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQLDialect"/>  <7>

            <property name="hibernate.show_sql" value="true"/>  <8>
            <property name="hibernate.format_sql" value="true"/>  <9>

            <property name="hibernate.hbm2ddl.auto" value="create"/>  <10>
        </properties>
    </persistence-unit>

</persistence>
----
<1> The persistence.xml file configures at least one persistence unit; each unit must
have a unique name.
<2> As JPA is only a specification, we need to indicate the vendor-specific PersistenceProvider implementation of the API. The persistence we define will be backed by a Hibernate provider.
<3> Indicate the JDBC properties—the driver.
<4> The URL of the database.
<5> The username.
<6> There is no password for access. The machine we are running the programs on
has MySQL 8 installed, and the access credentials are the ones from persistence.xml. You should modify the credentials to correspond to the ones on your
machine.
<7> The Hibernate dialect is PostgreSQLDialect, as the database to interact with is PostgreSQL.
<8> While executing, show the SQL code.
<9> Hibernate will format the SQL nicely and generate comments in the SQL string so
we know why Hibernate executed the SQL statement.
<10> Every time the program is executed, the database will be created from scratch.
This is ideal for automated testing, when we want to work with a clean database for
every test run.

== Writing a persistent class
The objective of this example is to store messages in a database and retrieve them for
display. The application has a simple persistent class, Message
[source,java,attributes]
----
package org.mine.kb.db.hibernate;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity <1>
public class Message {

    @Id <2>
    @GeneratedValue(strategy = GenerationType.IDENTITY) <3>
    private Long id;

    private String text; <4>

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

}
----
<1> Every persistent entity class must have at least the @Entity annotation. Hibernate maps this class to a table called MESSAGE.
<2> Every persistent entity class must have an identifier attribute annotated with @Id. Hibernate maps this attribute to a column named id.
<3> Someone must generate identifier values; this annotation enables automatic generation of ids. 
<4> We usually implement regular attributes of a persistent class with private fields and public getter/setter method pairs. Hibernate maps this attribute to a column called text.

The identifier attribute of a persistent class allows the application to access the database identity—the primary key value—of a persistent instance. If two instances of Message have the same identifier value, they represent the same row in the database. This
example uses Long for the type of identifier attribute, but this isn’t a requirement.
Hibernate allows you to use virtually anything for the identifier type, as you’ll see later
in the book.

You may have noticed that the text attribute of the Message class has JavaBeansstyle property accessor methods. The class also has a (default) constructor with no
parameters. The persistent classes we’ll show in the examples will usually look something like this. Note that we don’t need to implement any particular interface or
extend any special superclass.
Instances of the Message class can be managed (made persistent) by Hibernate,
but they don’t have to be. Because the Message object doesn’t implement any
persistence-specific classes or interfaces, we can use it just like any other Java class:
[source,java,attributes]
----
Message msg = new Message();
msg.setText("Hello!");
System.out.println(msg.getText());
----

It may look like we’re trying to be cute here; in fact, we’re demonstrating an important feature that distinguishes Hibernate from some other persistence solutions. We
can use the persistent class in any execution context—no special container is needed.

We don’t have to use annotations to map a persistent class. Later we’ll show other
mapping options, such as the JPA orm.xml mapping file and the native hbm.xml mapping files, and we’ll look at when they’re a better solution than source annotations, which are the most frequently used approach nowadays.

== Storing and loading
[source,java,attributes]
----
package org.mine.kb.db.hibernate;

import org.junit.jupiter.api.Test;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class HelloWorldJPATest {

    @Test
    public void storeLoadMessage() {

        EntityManagerFactory emf = Persistence.createEntityManagerFactory("java-db-hibernate-tutorial01-default"); <1>

        try {
            EntityManager em = emf.createEntityManager();
            em.getTransaction().begin();

            Message message = new Message();
            message.setText("Hello World!");

            em.persist(message);

            em.getTransaction().commit();
            // INSERT into MESSAGE (ID, TEXT) values (1, 'Hello World!')

            em.getTransaction().begin();

            List<Message> messages = em.createQuery("select m from Message m", Message.class).getResultList();
            // SELECT * from MESSAGE

            messages.get(messages.size() - 1).setText("Hello World from JPA!");

            em.getTransaction().commit();
            // UPDATE MESSAGE set TEXT = 'Hello World from JPA!' where ID = 1

            assertAll(
                    () -> assertEquals(1, messages.size()),
                    () -> assertEquals("Hello World from JPA!", messages.get(0).getText()));

            em.close();

        } finally {
            emf.close();
        }
    }

}
----
<1> First we need an EntityManagerFactory to talk to the database. This API
represents the persistence unit, and most applications have one EntityManagerFactory for one configured persistence unit. Once it starts, the application should
create the EntityManagerFactory; the factory is thread-safe, and all code in the
application that accesses the database should share it.
Begin a new session with the database by creating an EntityManager. This is the
context for all persistence operations.
Get access to the standard transaction API, and begin a transaction on this thread
of execution.
Create a new instance of the mapped domain model class Message, and set its text
property.
Enlist the transient instance with the persistence context; we make it persistent.
Hibernate now knows that we wish to store that data, but it doesn't necessarily call
the database immediately.
Commit the transaction. Hibernate automatically checks the persistence context
and executes the necessary SQL INSERT statement. To help you understand how
Hibernate works, we show the automatically generated and executed SQL statements in source code comments when they occur. Hibernate inserts a row in the
MESSAGE table, with an automatically generated value for the ID primary key column, and the TEXT value.
Every interaction with the database should occur within transaction boundaries,
even if we’re only reading data, so we start a new transaction. Any potential failure
appearing from now on will not affect the previously committed transaction.
Execute a query to retrieve all instances of Message from the database.
We can change the value of a property. Hibernate detects this automatically
because the loaded Message is still attached to the persistence context it was
loaded in.
On commit, Hibernate checks the persistence context for dirty state, and it executes the SQL UPDATE automatically to synchronize in-memory objects with the
database state.
Check the size of the list of messages retrieved from the database.
Check that the message we persisted is in the database. We use the JUnit 5 assertAll method, which always checks all the assertions that are passed to it, even if
some of them fail. The two assertions that we verify are conceptually related.
We created an EntityManager, so we must close it.
We created an EntityManagerFactory, so we must close it.

The query language here isn’t SQL, it’s the Jakarta Persistence
Query Language (JPQL). Although there is syntactically no difference in this trivial
example, the Message in the query string doesn’t refer to the database table name but
to the persistent class name. For this reason, the Message class name in the query is
case-sensitive. If we map the class to a different table, the query will still work.

== Native Hibernate configuration
Although basic (and extensive) configuration is standardized in JPA, we can’t access
all the configuration features of Hibernate with properties in persistence.xml.

When using native Hibernate we’ll use the Hibernate dependencies and API
directly, rather than the JPA dependencies and classes. JPA is a specification, and it
can use different implementations (Hibernate is one example, but EclipseLink is
another alternative) through the same API. Hibernate, as an implementation, provides its own dependencies and classes. While using JPA provides more flexibility, accessing the Hibernate implementation directly allows you to use features that are not covered by the JPA standard.

The native equivalent of the standard JPA EntityManagerFactory is the
org.hibernate.SessionFactory. We have usually one per application, and it involves
the same pairing of class mappings with database connection configuration.

To configure the native Hibernate, we can use a hibernate.properties Java properties file or a hibernate.cfg.xml XML file. 

[source,xml,attributes]
----
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
    <session-factory>
        <property name="hibernate.connection.driver_class">
            org.testcontainers.jdbc.ContainerDatabaseDriver
        </property>
        <property name="hibernate.connection.url">
            jdbc:tc:postgresql:14.12:///test-hibernate
        </property>
        <property name="hibernate.connection.username">user</property>
        <property name="hibernate.connection.password">password</property>
        <property name="hibernate.connection.pool_size">50</property>
        <property name="show_sql">true</property>
        <property name="hibernate.hbm2ddl.auto">create</property>
    </session-factory>
</hibernate-configuration>
----
[source,java,attributes]
----
package org.mine.kb.db.hibernate;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.hibernate.service.ServiceRegistry;
import org.junit.jupiter.api.Test;

import javax.persistence.criteria.CriteriaQuery;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;

@Testcontainers
public class AppHibernateNativeTest {
    // Defines a PostgreSQL container for testing
    // @Container
    // static PostgreSQLContainer<?> postgresql = new
    // PostgreSQLContainer<>(DockerImageName.parse("postgres:14.12"));
    public static PostgreSQLContainer<?> postgresContainer = new PostgreSQLContainer<>("postgres:14.12")
            .withDatabaseName("test-hibernate")
            .withUsername("user")
            .withPassword("password");

    @BeforeAll
    static void startContainer() {
        postgresContainer.start();
    }

    @AfterAll
    static void stopContainer() {
        postgresContainer.stop();
    }

    private static SessionFactory createSessionFactory() {
        Configuration configuration = new Configuration(); <1>
        configuration.configure().addAnnotatedClass(Message.class);
        ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
                .applySettings(configuration.getProperties()).build();
        return configuration.buildSessionFactory(serviceRegistry);
    }

    @Test
    public void storeLoadMessage() {

        try (SessionFactory sessionFactory = createSessionFactory();
                Session session = sessionFactory.openSession()) {
            session.beginTransaction();

            Message message = new Message();
            message.setText("Hello World from Hibernate!");

            session.persist(message);

            session.getTransaction().commit();
            // INSERT into MESSAGE (ID, TEXT)
            // values (1, 'Hello World from Hibernate!')
            session.beginTransaction();

            CriteriaQuery<Message> criteriaQuery = session.getCriteriaBuilder().createQuery(Message.class);
            criteriaQuery.from(Message.class);

            List<Message> messages = session.createQuery(criteriaQuery).getResultList();
            // SELECT * from MESSAGE

            session.getTransaction().commit();

            assertAll(
                    () -> assertEquals(1, messages.size()),
                    () -> assertEquals("Hello World from Hibernate!", messages.get(0).getText()));
        }
    }
}
----
<1> To create a SessionFactory, we first need to create a configuration.
We need to call the configure method on it and to add Message to it as an annotated class. The execution of the configure method will load the content of the
default hibernate.cfg.xml file.
The builder pattern helps us create the immutable service registry and configure it
by applying settings with chained method calls. A ServiceRegistry hosts and manages services that need access to the SessionFactory. Services are classes that provide pluggable implementations of different types of functionality to Hibernate.
Build a SessionFactory using the configuration and the service registry we have
previously created.
The SessionFactory created with the createSessionFactory method we previously defined is passed as an argument to a try with resources, as SessionFactory
implements the AutoCloseable interface.
Similarly, we begin a new session with the database by creating a Session, which
also implements the AutoCloseable interface. This is our context for all persistence operations.
Get access to the standard transaction API and begin a transaction on this thread
of execution.
Create a new instance of the mapped domain model class Message, and set its text
property.
Enlist the transient instance with the persistence context; we make it persistent.
Hibernate now knows that we wish to store that data, but it doesn't necessarily call
the database immediately. The native Hibernate API is pretty similar to the standard JPA, and most methods have the same name.
Synchronize the session with the database, and close the current session on commit of the transaction automatically.
Begin another transaction. Every interaction with the database should occur
within transaction boundaries, even if we’re only reading data.
Create an instance of CriteriaQuery by calling the CriteriaBuilder createQuery() method. A CriteriaBuilder is used to construct criteria queries, compound selections, expressions, predicates, and orderings. A CriteriaQuery defines
functionality that is specific to top-level queries. CriteriaBuilder and CriteriaQuery belong to the Criteria API, which allows us to build a query programmatically.
Create and add a query root corresponding to the given Message entity.
Call the getResultList() method of the query object to get the results. The
query that is created and executed will be SELECT * FROM MESSAGE.
Commit the transaction.
Check the size of the list of messages retrieved from the database.
Check that the message we persisted is in the database. We use the JUnit 5 assertAll method, which always checks all the assertions that are passed to it, even if
some of them fail. The two assertions that we verify are conceptually related.

== Switching between JPA and Hibernate
Suppose you’re working with JPA and need to access the Hibernate API. Or, vice versa,
you’re working with native Hibernate and you need to create an EntityManagerFactory from the Hibernate configuration. To obtain a SessionFactory from an EntityManagerFactory, you’ll have to unwrap the first one from the second one.

Starting with JPA version 2.0, you can get access to the APIs of the underlying implementations. The EntityManagerFactory (and also the EntityManager) declares an
unwrap method that will return objects belonging to the classes of the JPA implementation. When using the Hibernate implementation, you can get the corresponding
SessionFactory or Session objects and start using them. When a particular feature is only available in Hibernate, you can switch to it using the unwrap method.

[tabs]
====
persistence.xml::
+
[source, xml]
----
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"
             version="2.0">

    <persistence-unit name="java-db-hibernate-tutorial03-switching-jpa-hibernate-test">
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
        <class>org.mine.kb.db.hibernate.Message</class>
        <properties>
            <property name="javax.persistence.jdbc.driver" value="org.testcontainers.jdbc.ContainerDatabaseDriver"/>
            <property name="javax.persistence.jdbc.url" value="jdbc:tc:postgresql:14.12:///test-hibernate"/>
            <property name="javax.persistence.jdbc.user" value="user"/>
            <property name="javax.persistence.jdbc.password" value="password"/>

            <property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQLDialect"/>

            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.format_sql" value="true"/>

            <property name="hibernate.hbm2ddl.auto" value="update"/>
        </properties>
    </persistence-unit>

</persistence>
----

JPAToHibernateTest.java::
+
[source, java]
----
package org.mine.kb.db.hibernate;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.hibernate.service.ServiceRegistry;
import org.junit.jupiter.api.Test;

import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import javax.persistence.criteria.CriteriaQuery;
import java.util.List;

import org.junit.jupiter.api.Test;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import org.testcontainers.utility.DockerImageName;

import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;

@Testcontainers
public class JPAToHibernateTest {
    // Defines a PostgreSQL container for testing
    // @Container
    // static PostgreSQLContainer<?> postgresql = new
    // PostgreSQLContainer<>(DockerImageName.parse("postgres:14.12"));
    public static PostgreSQLContainer<?> postgresContainer = new PostgreSQLContainer<>("postgres:14.12")
            .withDatabaseName("test-hibernate")
            .withUsername("user")
            .withPassword("password");

    @BeforeAll
    static void startContainer() {
        postgresContainer.start();
    }

    @AfterAll
    static void stopContainer() {
        postgresContainer.stop();
    }

    private static SessionFactory getSessionFactory(EntityManagerFactory entityManagerFactory) {
        return entityManagerFactory.unwrap(SessionFactory.class);
    }

    @Test
    public void storeLoadMessage() {

        EntityManagerFactory emf = Persistence
                .createEntityManagerFactory("java-db-hibernate-tutorial03-switching-jpa-hibernate-test");

        try (SessionFactory sessionFactory = getSessionFactory(emf)) {
            Session session = sessionFactory.openSession();
            session.beginTransaction();

            Message message = new Message();
            message.setText("Hello World from Hibernate!");

            session.persist(message);

            session.getTransaction().commit();
            // INSERT into MESSAGE (ID, TEXT)
            // values (1, 'Hello World from Hibernate!')
            session.beginTransaction();

            CriteriaQuery<Message> criteriaQuery = session.getCriteriaBuilder().createQuery(Message.class);
            criteriaQuery.from(Message.class);

            List<Message> messages = session.createQuery(criteriaQuery).getResultList();
            // SELECT * from MESSAGE

            session.getTransaction().commit();

            assertAll(
                    () -> assertEquals(1, messages.size()),
                    () -> assertEquals("Hello World from Hibernate!", messages.get(0).getText()));
        }
    }
}
----
====
the reverse operation: creating an EntityManagerFactory from an initial Hibernate configuration.
[tabs]
====
hibernate.cfg.xml::
+
[source, xml]
----
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
    <session-factory>
        <property name="hibernate.connection.driver_class">
            org.testcontainers.jdbc.ContainerDatabaseDriver
        </property>
        <property name="hibernate.connection.url">
            jdbc:tc:postgresql:14.12:///test-hibernate
        </property>
        <property name="hibernate.connection.username">user</property>
        <property name="hibernate.connection.password">password</property>
        <property name="hibernate.connection.pool_size">50</property>
        <property name="show_sql">true</property>
        <property name="hibernate.hbm2ddl.auto">create</property>
    </session-factory>
</hibernate-configuration>
----

HibernateToJPATest.java::
+
[source, java]
----
package org.mine.kb.db.hibernate;

import org.hibernate.cfg.Configuration;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.testcontainers.containers.PostgreSQLContainer;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import java.util.*;

import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class HibernateToJPATest {
        // Defines a PostgreSQL container for testing
    // @Container
    // static PostgreSQLContainer<?> postgresql = new
    // PostgreSQLContainer<>(DockerImageName.parse("postgres:14.12"));
    public static PostgreSQLContainer<?> postgresContainer = new PostgreSQLContainer<>("postgres:14.12")
            .withDatabaseName("test-hibernate")
            .withUsername("user")
            .withPassword("password");

    @BeforeAll
    static void startContainer() {
        postgresContainer.start();
    }

    @AfterAll
    static void stopContainer() {
        postgresContainer.stop();
    }

    private static EntityManagerFactory createEntityManagerFactory() {
        Configuration configuration = new Configuration(); <1>
        configuration.configure().addAnnotatedClass(Message.class);

        Map<String, String> properties = new HashMap<>();
        Enumeration<?> propertyNames = configuration.getProperties().propertyNames();
        while (propertyNames.hasMoreElements()) {
            String element = (String) propertyNames.nextElement();
            properties.put(element, configuration.getProperties().getProperty(element));
        }

        return Persistence.createEntityManagerFactory("java-db-hibernate-tutorial03-switching-jpa-hibernate-test", properties);
    }

    @Test
    public void storeLoadMessage() {

        EntityManagerFactory emf = createEntityManagerFactory();

        try {

            EntityManager em = emf.createEntityManager();
            em.getTransaction().begin();

            Message message = new Message();
            message.setText("Hello World from Hibernate to JPA!");

            em.persist(message);

            em.getTransaction().commit();
            // INSERT into MESSAGE (ID, TEXT) values (1, 'Hello World from Hibernate to
            // JPA!')

            List<Message> messages = em.createQuery("select m from Message m", Message.class).getResultList();
            // SELECT * from MESSAGE

            assertAll(
                    () -> assertEquals(1, messages.size()),
                    () -> assertEquals("Hello World from Hibernate to JPA!", messages.get(0).getText()));

            em.close();

        } finally {
            emf.close();
        }
    }
}
----
+
//// <1> Create a new Hibernate configuration.
<2> Call the configure method, which adds the content of the default hibernate.cfg.xml file to the configuration, and then explicitly add Message as an annotated class.
<3> Create a new hash map to be filled in with the existing properties.
<4> Get all the property names from the Hibernate configuration.
<5> Add the property names one by one to the previously created map.
<6> Return a new EntityManagerFactory, providing to it the ``java-db-hibernate-tutorial03-switching-jpa-hibernate-test`` persistence unit name and the previously created map of properties ////
====
