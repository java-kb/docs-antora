= AI timesheet manager

let’s undergo the process of creating part of a feature for a sample timesheet manager:

* As a timesheet user, I want to be able to track time against specific projects so 
that I can keep a history of how much time I have spent working on individual 
projects.
* Features:
** Time is tracked in half hour units.
** To complete a timesheet, a project and amount of time must be entered.
** Only I should be able to see my tracked time.

== Analysing user stories

You are a software testing expert. Analyze the text delimited by triple hashes and generate questions that will clarify ambiguities in the text.
* Questions will be generated by using the What, Where, Why, When, Who and How
heuristic
* Multiple questions can be identified for each quality characteristic
* The quality characteristics we care about are: Accuracy and Consistency
* Output questions in the format of Question - Explanation
Example:
What does relevant mean?
The acceptance criteria say relevant search results, but how do we determine what is
relevant and what isn’t?
###
As a timesheet user
I want to be able to track time against specific projects
So that I can keep a history of how much time I have spent working on individual
projects
Features:
- Time is tracked in half hour units
- To complete a timesheet a project and amount of time must be entered
- Only I should be able to see my tracked time
###

[tabs]
======
ChatGPT::
Below are clarifying questions focused on Accuracy and Consistency, generated using the What / Where / Why / When / Who / How heuristic. Each question highlights an ambiguity in the text.

Accuracy

What does “track time” mean exactly?
Does tracking mean manual entry only, or does it include timers (start/stop) and automatic calculations?

What qualifies as a “project”?
Is a project a predefined entity created elsewhere, or can users create projects while entering a timesheet?

What does “half hour units” mean in practice?
Does this mean time can only be entered in increments of 0.5 hours, or can smaller units be rounded to the nearest half hour?

How is rounding handled for time entries?
If a user works 45 minutes, is it rounded up to 1 hour, down to 0.5 hours, or rejected?

When is a timesheet considered “complete”?
Is completion a manual action by the user, or does it happen automatically once required fields are filled?

What time period does a timesheet cover?
Is a timesheet daily, weekly, monthly, or user-defined?

Consistency

Who is “I” in “Only I should be able to see my tracked time”?
Does this strictly mean the individual user, or are admins/managers allowed access under certain conditions?

Where is tracked time visible once entered?
Is it shown in reports, dashboards, exports, or only within the timesheet screen?

How does this feature behave across multiple projects?
Can a single timesheet include multiple projects, and if so, must the half-hour rule apply consistently per project entry?

What happens if a project is deleted or archived?
Is previously tracked time preserved, hidden, or reassigned to maintain historical consistency?

Why is the half-hour unit constraint required?
Is this a business rule, a reporting requirement, or a billing constraint that must be applied consistently everywhere?

How is consistency enforced across different devices or interfaces?
Will the same validation rules apply if time is entered via web, mobile, or API?

Gemini::
As a software testing expert, I have analyzed the provided user story and features. While the requirements provide a basic framework, several ambiguities regarding Accuracy and Consistency could lead to defects or misaligned expectations during development.

Here are the clarifying questions using the 5W1H heuristic:
Accuracy

These questions focus on ensuring the requirements are precise and reflect the intended reality of the system.

    How should the system handle time entries that are not in 30-minute increments?

        The requirement states time is tracked in "half hour units," but it does not specify if the system should round up, round down, round to the nearest unit, or simply reject any input (e.g., 15 minutes) that isn't a multiple of 0.5.

    What is the maximum amount of time that can be entered for a single project or day?

        To ensure data accuracy, we need to know if there are "sanity check" limits. Can a user accidentally enter 100 hours for a single day, or is there a 24-hour validation limit?

    Who, besides the individual user, has permission to view these records for payroll or project management?

        The text states "Only I should be able to see my tracked time." In a business context, this is often inaccurate as managers or admins usually require access for billing or approval. We need to clarify if "Only I" refers to other standard users or if it literally excludes all other roles.

    When is a timesheet considered "complete"?

        The requirement says a project and amount of time must be entered to "complete" a timesheet. It is unclear if "complete" refers to saving a single line item, or if there is a formal "Submit" action that locks the timesheet for a specific period (like a week).

Consistency

These questions focus on ensuring the requirements do not contradict themselves or other system behaviors.

    Where do the "specific projects" come from, and is the list filtered for the user?

        To maintain consistency across the platform, we need to know if users select from a global list of projects or only projects they are assigned to. If they can type in any name, the "history" will become fragmented and inaccurate.

    How is the "history" displayed to the user?

        The user wants to keep a history of spent time. We need to define if this history is a daily, weekly, or monthly view to ensure the "half hour units" are aggregated consistently across different reports.

    Why is there no mention of a "date" field for the time entry?

        For the history to be consistent and useful, time must be tracked against a specific date. The current requirements only mention "Project" and "Amount of time." We need to clarify if the system defaults to the current date or allows backdating.

    What happens to the "history" if a project is deleted or renamed?

        To ensure consistency, we need to know if the history remains static or if it updates/disappears when the project's status changes in the system.
======

From here, I read each of the questions sent back to me and noted the ones that stood 
out as raising points I hadn’t considered

* at some point, we need to add date–time handling into the code to prevent problems around invalid entries.
* We plan to just track the amount oftime carried out and not when it was carried out (at least for now).
* We opted for simply tracking the amount of time that had elapsed and not specifically when it had occurred, meaning that the displaying of information is relatively straightforward.
* At this time, there is no multiple-user feature, although it might be introduced later, so I make a note to consider this for future iterations.

Many more questions could be asked and addressed, but what this process demonstrates is that, by generating different questions, I am required to think about various aspects of this feature’s design. Some I can choose to rule out, or shelve for later conversation, and some help me to improve the quality of my feature by raising my awareness to validation and date–time formatting.

== Loop 1: Save a timesheet entry
With the questions from the previous prompt in my mind, I start my first loop by creating an empty maven project within my IDE before heading to the pom.xml to add 
my required dependencies. I require JUnit 5 to build my unit checks, so I entered the comment
MW <!-- Junit jupiter engine-->


<dependencies>
<dependency>
<groupId>org.junit.jupiter</groupId>
<artifactId>junit-jupiter-engine</artifactId>
<version>5.8.2</version>
<scope>test</scope>
</dependency>

Prompt: create  create an empty maven project  with JUnit 5 dependency at the root of this folder write down the command used to generate this project

mvn -B archetype:generate -DgroupId=com.example -DartifactId=generative-ai-and-testing-2024 -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false


Prompet: create TimesheetTest test class
Test that when a timesheet is submitted with a project name and hours it returns true

[tabs]
====
src/main/java/com/example/timesheet/Timesheet.java::
+
[source, java]
----
package com.example.timesheet;

public class Timesheet {

    /**
     * Submit a timesheet entry.
     * Returns true when the project name is non-empty and hours > 0.
     * Valid submissions are stored and can be retrieved via {@link #getEntries()}.
     */
    public boolean submit(String projectName, double hours) {
        if (projectName == null) return false;

        String trimmed = projectName.trim();
        if (trimmed.isEmpty()) return false;

        if (hours <= 0) return false;

        entries.add(new Entry(trimmed, hours));
        
        return true;
    }
}

----

src/test/java/com/example/timesheet/TimesheetTest.java::
+
[source, java]
----
package com.example.timesheet;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertTrue;

public class TimesheetTest {

    @Test
    public void testSubmitReturnsTrueWhenProjectAndHoursProvided() {
        Timesheet timesheet = new Timesheet();
        boolean result = timesheet.submit("Project X", 8.0);
        assertTrue(result, "Timesheet.submit should return true when project and hours are provided");
    }
}

----
====

== Loop 2: Retrieve a timesheet entry
Prompt: Test that when timesheets are added they can be retrieved as a list
[tabs]
====
src/main/java/com/example/timesheet/Timesheet.java::
+
[source, java]
----
package com.example.timesheet;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Timesheet {

    private final List<Entry> entries = new ArrayList<>();

    /**
     * Submit a timesheet entry.
     * Returns true when the project name is non-empty and hours > 0.
     * Valid submissions are stored and can be retrieved via {@link #getEntries()}.
     */
    public boolean submit(String projectName, double hours) {
        if (projectName == null) return false;

        String trimmed = projectName.trim();
        if (trimmed.isEmpty()) return false;

        if (hours <= 0) return false;

        entries.add(new Entry(trimmed, hours));
        
        return true;
    }

    /**
     * Returns an immutable copy of submitted entries.
     */
    public List<Entry> getEntries() {
        return Collections.unmodifiableList(new ArrayList<>(entries));
    }

    public static final class Entry {
        private final String projectName;
        private final double hours;

        public Entry(String projectName, double hours) {
            this.projectName = projectName;
            this.hours = hours;
        }

        public String getProjectName() {
            return projectName;
        }

        public double getHours() {
            return hours;
        }
    }
}

----

src/test/java/com/example/timesheet/TimesheetTest.java::
+
[source, java]
----
package com.example.timesheet;

import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class TimesheetTest {

    @Test
    public void testSubmitReturnsTrueWhenProjectAndHoursProvided() {
        Timesheet timesheet = new Timesheet();
        boolean result = timesheet.submit("Project X", 8.0);
        assertTrue(result, "Timesheet.submit should return true when project and hours are provided");
    }

    @Test
    public void testAddedTimesheetsAreRetrievableAsList() {
        Timesheet timesheet = new Timesheet();
        timesheet.submit("Alpha", 4.5);
        timesheet.submit("Beta", 3.0);

        List<Timesheet.Entry> entries = timesheet.getEntries();
        assertEquals(2, entries.size(), "There should be two submitted entries");
        assertEquals("Alpha", entries.get(0).getProjectName());
        assertEquals(4.5, entries.get(0).getHours());
        assertEquals("Beta", entries.get(1).getProjectName());
        assertEquals(3.0, entries.get(1).getHours());
    }
}

----
====

== Loop 3: Calculating times for a project
Prompt: Test that the total hours worked can be calculated from a list of timesheets from one project

We need to update submitTimesheet to handle duplicate projects, which I do by dropping the following comment into submitTimesheet, just after the initial if statement:

MW // Check to see if project already exists
[tabs]
====
src/main/java/com/example/timesheet/Timesheet.java::
+
[source, java]
----
package com.example.timesheet;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Timesheet {

    private final List<Entry> entries = new ArrayList<>();

    /**
     * Returns the total hours recorded for the given project name.
     * If the projectName is null or not present, returns 0.0.
     */
    public double totalHoursForProject(String projectName) {
        if (projectName == null) return 0.0;
        double sum = 0.0;
        for (Entry e : entries) {
            if (projectName.equals(e.getProjectName())) {
                sum += e.getHours();
            }
        }
        return sum;
    }
}
----

src/test/java/com/example/timesheet/TimesheetTest.java::
+
[source, java]
----
package com.example.timesheet;

import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class TimesheetTest {

    @Test
    public void testTotalHoursForSingleProject() {
        Timesheet timesheet = new Timesheet();
        timesheet.submit("Alpha", 4.5);
        timesheet.submit("Alpha", 2.0);
        timesheet.submit("Beta", 3.0);

        double total = timesheet.totalHoursForProject("Alpha");
        assertEquals(6.5, total, 1e-9, "Total hours for Alpha should be 6.5");
    }
}
----
====

== Refactoring code
Prompt:

You are a software testing expert. Analyze the Java code and identify risks that might impact the code. If no code is provided, respond with “No risks could be found”
* Risks must be related to the quality characteristics: Accuracy and Consistency
* Multiple risks can be identified for each quality characteristic
* Output identified risks in the format of Risk - Quality Characteristic - Explanation
Example:
Overflow - Security - Adding in large integers as parameters might cause the method
to trigger a buffer overflow.