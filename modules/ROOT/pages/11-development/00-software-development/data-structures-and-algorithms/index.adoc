= Data structures and Algorithms
:figures: 11-development/00-software-development/data-structures-and-algorithms
:pp: {plus}{plus}




Logarithmic complexity algorithms are very fast, and their performance hardly degrades as
you increase the problem size. These types of algorithm scale really well. Code that has a
runtime complexity of O(log n) is usually recognizable since it systematically divides the
input in several steps.

*Exampeles*

. database indexes
. binary trees. If we want to find an item in a list, we can do it much more
efficiently if the input list is sorted in some specific order. We can then use this ordering by
jumping to specific positions of our list and skipping over a number of elements.
+
[,java]
----
 public boolean binarySearch(int x, int[] sortedNumbers) {
     int end = sortedNumbers.length - 1;
     int start = 0;
     while (start <= end) {
         int mid = (end - start) / 2 + start;
         if (sortedNumbers[mid] == x) return true;
         else if (sortedNumbers[mid] > x) end = mid - 1;
         else start = mid + 1;
     }
     return false;
 }
----
+
The method uses three array pointers--a start, an end, and a midpoint. The algorithm starts by checking the
 middle element in the array. If the element is not found and is less than the value at the
 middle, we choose to search in the lower half; otherwise, we choose the upper half
 image::{figures}/image.png[alt text]
+
==== Exponential Complexity
+
algorithms that have an exponential runtime complexityO(k{caret}n) scale really poorly.
*Exampeles*

. traveling salesman problem
. cracking a password using a brute force approach
. prime factorization: given an integer input, find all the prime numbers that are factors of the input (primes that when multiplied together give us the input).
+
If we take an input decimal number of n digits, this algorithm would perform in O(10n) in the worst case.
 The algorithm works by using a counter (called factor) starting at two and
 checks whether if it's a factor of the input. This check is done by using the modulus
 operator. If the modulus operation leaves no remainder, then the value of the counter is a
 factor and is added to the factor list. The input is then divided by this factor. If the counter
 is not a factor (the mod operation leaves a remainder), then the counter is incremented by
 one. This continues until x is reduced to one.
+
[,java]
----
 public List<Long> primeFactors(long x) {
         ArrayList<Long> result = new ArrayList<>();
         long factor = 2;
         while (x > 1) {
             if (x % factor == 0) {
                 result.add(factor);
                 x /= factor;
             } else {
                 factor += 1;
             }
         }
         return result;
     }
----
+
The worst case of the algorithm is when the input is a prime number, wherein it needs to sequentially count all the way up to the prime number.
+
==== Constant Complexity
+
The efficiency of constant runtime algorithms remains fixed as we increase the input size.
Many examples of these exist
*Exampeles*

. accessing an element in an array.
Access performance doesn't depend on the size of the array, so as we increase the size of
the array, the access speed stays constant.
. Many of the simple mathematical functions, such as finding the distance
between two points and mapping a three-dimensional coordinate to a two-dimensional
one, all fall under this class
+
[,java]
----
 private double circleCircumference(int radius) {
 return 2.0 * Math.PI * radius;
 }
----
+
The number of operations performed remains constant,
 irrespective of the size of the input radius. Such an algorithm is said to have a runtime
 complexity of O(1)
+
== Data structures
+
'''
+
A data structure is a way of organizing data so that it can be accessed and/or modified efficiently.
