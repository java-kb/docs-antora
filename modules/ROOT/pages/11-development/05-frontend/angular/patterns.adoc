= Angular Best Practices and Patterns

== Patterns
=== SharedModule pattern(Optimizing the usage of common modules)
If we look at Angular projects, we will see patterns of use of modules such as HttpModule, To avoid code duplication and also make it easier for new team members, don’t forget to add an 
important module to the project; we can create the SharedModule call to centralize the common 
dependencies of an Angular project. In this module, we are importing Angular Material’s dependencies and exporting the same dependencies, without declaring any component, directive, or pipe. In the home.module.ts file, we can refactor to use SharedModule:

The modules present in SharedModule must be modules common to the majority of modules 
in your project, as this can increase the size of the module’s bundle. If the module needs some 
specific dependency, you must declare it in that dependency and not in SharedModule.

[tabs]
====
shared.module.ts::
+
[source,typescript,attributes]
----
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { LayoutModule } from '@angular/cdk/layout';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatListModule } from '@angular/material/list';
import { MatSidenavModule } from '@angular/material/sidenav';
import { MatToolbarModule } from '@angular/material/toolbar';

@NgModule({
  imports: [
    CommonModule,
    LayoutModule,
    MatToolbarModule,
    MatButtonModule,
    MatSidenavModule,
    MatIconModule,
    MatListModule,
  ],
  exports: [
    CommonModule,
    LayoutModule,
    MatToolbarModule,
    MatButtonModule,
    MatSidenavModule,
    MatIconModule,
    MatListModule,
  ]
})
export class SharedModule { }
----

home.module.ts::
+
[source, typescript]
----
import { NgModule } from '@angular/core';
import { HomeComponent } from './home/home.component';
import { SharedModule } from '../shared/shared.module';
import { HomeRoutingModule } from './home-routing.module';

@NgModule({
  declarations: [HomeComponent],
  imports: [
    SharedModule,HomeRoutingModule
  ]
})
export class HomeModule {}
----
====

=== lazy loading(Improving the size of your app)
A good strategy for separating modules from your Angular application will increase your team’s 
productivity and improve code organization. But another advantage that will impact the quality for 
your user is the use of the lazy loading technique for modules.

If we run the build process of the sample application using the ng build command, we can see 
that the size of our application’s initial bundle (the main.ts file) is 94.73 kB, which may seem small, but 
for the size of our application with few features, it is a considerable size.

As the project has more features, the tendency is for this initial bundle to increase considerably, harming 
our users’ experience as they will initially need to download a larger file. This problem particularly 
manifests itself in environments where the internet is not very good, such as 3G networks.
To reduce this file and consequently improve our user experience, the ideal is to have smaller packages 
and for these packages to be loaded only when necessary – that is, in a lazy way.

the most important part is the loadChildren attribute. This is where we configure 
the lazy load, as we pass to Angular’s route mechanism a function that returns an import promise.
Note that the import function is not an Angular function, but a standard JavaScript function that allows 
dynamic loading of code. Angular’s route engine uses this language feature to bring this functionality.

Running our application with the ng serve command, we didn’t notice any difference. However, 
when executing the ng build command, we can notice the following diagnosis: The Angular build process has separated the Home module into its own bundle and the main.ts
bundle has been made smaller. The difference may seem small but note that, this way, our application 
can scale and grow in complexity and the initial bundle will remain small or grow very little.


[tabs]
====
home-routing.module.ts::
+
[source,typescript,attributes]
----
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { HomeComponent } from './home/home.component';

const routes: Routes = [
  {
    path: '',
    component: HomeComponent,
  },
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule],
})
export class HomeRoutingModule {}
----

app-routing.module.ts::
+
[source, typescript]
----
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';

const routes: Routes = [
  { path: '', pathMatch: 'full', redirectTo: 'home' },
  {
    path: 'home',
    loadChildren: () =>
      import('./home/home.module').then((file) => file.HomeModule),
  },
];
@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
})
export class AppRoutingModule {}
----
====
The new features continue to exist and be loaded by the application, but the initial loading will be 
faster, and these new features will be downloaded on demand only when the user accesses the route 
they want, giving a very positive fluidity and responsiveness.

Lazy loading for standalone components works similarly to lazy loading for NgModule-based components, but with a streamlined syntax.

Instead of using loadChildren to load an NgModule, you use loadComponent in your route configuration to directly load a standalone component.
[source,typescript,attributes]
----
// app.routes.ts
import { Route } from '@angular/router';

export const routes: Route[] = [
  {
    path: 'admin',
    loadComponent: () => import('./admin/admin.component').then(m => m.AdminComponent)
  },
  // ... other routes
];
----
In this example, the AdminComponent (which is a standalone component) will only be loaded when the user navigates to the /admin route. This ensures that the code for the admin section is not included in the initial bundle, improving the application's startup performance.

=== Separating responsibilities – Smart and Presentation components
The information flow of a single-page application (SPA) can be quite complex and, if you don’t think 
about this flow from the beginning of your design, it can affect the productivity and quality of your 
project over time.

a very common design pattern not only in Angular applications but 
also in SPAs in general is the composition of interfaces using Smart and Presentation components. In 
literature and in the community, you will also find this pattern under the name of Smart and Dumb
components or Container and Presentation components.

A Smart component has the UI business rule; it is where we will have injected the services that will 
communicate with the backend and where the interface with the Presentation components will 
be composed.
A Presentation component is a component that has the sole purpose of showing the data passed by 
the Smart component, normally via input. A Presentation component in turn can contain one or more 
components of the Presentation type.

Notice that we have a source of truth, which is the Smart component, and the communication occurs 
in only one direction, this is what we call a Unidirectional Data Flow. The purpose of this pattern is 
to isolate all states within a component and thereby simplify state management.

[tabs]
======

Calaculator Example::

Gym Diary::
+
Let’s refactor our project to fit this design pattern. Let’s create a new presentation component using 
the Angular CLI:
+
  ng g c diary/list-entries
+
In this new component, we are going to move the part that renders the list of diary entries into your 
template.
+
The list that will be displayed will come ready from the DiaryComponent component.
+
Here, we move the itemTrackBy function into the component, as it will be its function to display
the list, and we include the exerciseList attribute with the @Input decorator. In this example, we 
didn’t specify any parameters, so the name of the template’s attribute will be the same as the attribute 
of the exerciseList class.
+
Let’s change the Diary template in the diary.component.html file to use the new presentation 
component we have created:
+
<app-list-entries [exerciseList]="exerciseList" />
+
The DiaryComponent Smart component just passes the list to the ListEntriesComponent
Presentation component, which iterates over the list by calling the EntryItemComponent
Presentation component. With this structure, only the DiaryComponent component needs to 
worry about the list of exercises, respecting SOLID’s Single Responsibility concept.

[tabs]
====
chapters/ch04-gym-diary/src/app/diary/diary/diary.html::
+
[source, html]
----
<div class="min-h-screen bg-gray-200">
  <header class="bg-blue-500 py-4 text-white">
    <div class="mx-auto max-w-6xl px-4">
      <h1 class="text-2xl font-bold">Workout diary</h1>
    </div>
  </header>
  <main class="mx-auto mt-8 max-w-6xl px-4">
    <app-list-entries [exerciseList]="exerciseList" (deleteEvent)="deleteItem($event)" (newRepEvent)="newRep($event)" />
    <app-new-item-button (newExerciseEvent)="addExercise($event)" />
    <br />
    <br />

    <button class="rounded bg-blue-500 py-2 px-4 font-bold text-white hover:bg-blue-700" (click)="newList()">
      Server Sync
    </button>
  </main>
</div>
----

chapters/ch04-gym-diary/src/app/diary/diary/diary.ts::
+
[source, typescript]
----
import { Component, inject } from '@angular/core';
import { BreakpointObserver, Breakpoints } from '@angular/cdk/layout';
import { AsyncPipe, CommonModule } from '@angular/common';
import { Observable } from 'rxjs';
import { map, shareReplay } from 'rxjs/operators';
import { EntryItem } from '../../diary/entry-item/entry-item';
import { ExerciseSet, ExerciseSetList } from '../../diary/interfaces/exercise-set';
import { ListEntries } from '../list-entries/list-entries';
import { NewItemButton } from "../new-item-button/new-item-button";

@Component({
  selector: 'app-diary',
  imports: [ListEntries, NewItemButton],
  templateUrl: './diary.html',
  styleUrl: './diary.css',
})
export class Diary {

  exerciseList: ExerciseSetList = [
    {
      id: '1', date: new Date(), exercise: 'Deadlift', reps: 15, sets:
        3
    },
    {
      id: '2', date: new Date(), exercise: 'Squat', reps: 15, sets: 3
    },
    {
      id: '3', date: new Date(), exercise: 'Barbell row', reps: 15,
      sets: 3
    },
  ];

  newList() {
    this.exerciseList = [
      {
        id: '1', date: new Date(), exercise: 'Deadlift', reps: 15,
        sets: 3
      },
      {
        id: '2', date: new Date(), exercise: 'Squat', reps: 15, sets: 3
      },
      {
        id: '3', date: new Date(), exercise: 'Barbell row', reps: 15,
        sets: 3
      },
      {
        id: '4', date: new Date(), exercise: 'Leg Press', reps: 15,
        sets: 3
      },
    ];
  }

  addExercise(newSet: ExerciseSet) {
    this.exerciseList.push(newSet);
  }

  deleteItem(id: string) {
    this.exerciseList = this.exerciseList.filter((item) => item.id !==
      id);
  }
  newRep(exerciseSet: ExerciseSet) {
    const id = exerciseSet.id;
    const i = this.exerciseList.findIndex((item) => item.id === id);
    if (i >= 0) {
      this.exerciseList[i] = { ...exerciseSet };
    }
  }
}


----

src/app/diary/list-entries/list-entries.html::
+
[source, html]
----
<section class="mb-8">
    <h2 class="mb-4 text-xl font-bold">List of entries</h2>
    <ul class="rounded border shadow">
        <li *ngFor="let item of exerciseList; index as i; trackBy: itemTrackBy">
            <app-entry-item [exercise-set]="item" (deleteEvent)="deleteEvent.emit($event)"
                (newRepEvent)="newRepEvent.emit($event)" />
        </li>
    </ul>
</section>
----

chapters/ch04-gym-diary/src/app/diary/list-entries/list-entries.ts::
+
[source, typescript]
----
import { CommonModule } from '@angular/common';
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { ExerciseSet, ExerciseSetList } from '../interfaces/exercise-set';
import { EntryItem } from "../entry-item/entry-item";

@Component({
  selector: 'app-list-entries',
  imports: [CommonModule, EntryItem],
  templateUrl: './list-entries.html',
  styleUrl: './list-entries.css',
})
export class ListEntries {

  @Input() exerciseList!: ExerciseSetList;

  @Output() newRepEvent = new EventEmitter<ExerciseSet>();
  @Output() deleteEvent = new EventEmitter<string>();

  itemTrackBy(index: number, item: ExerciseSet) {
    return item.id;
  }

}

----

chapters/ch04-gym-diary/src/app/diary/entry-item/entry-item.html::
+
[source, html]
----
<div class="mb-4 flex items-center justify-between border-b bg-white p-4">
    <div>
        <span class="font-bold">Date:</span> {{ exerciseSet.date | date }}<br />
        <span class="font-bold">Exercise:</span> {{ exerciseSet.exercise }}<br />
        <span class="font-bold">Sets:</span> {{ exerciseSet.sets }}<br />
        <span class="font-bold">Reps:</span> {{ exerciseSet.reps }}
    </div>
    <div class="flex items-center">
        <button class="mr-2 rounded bg-red-500 py-2 px-4 font-bold text-white hover:bg-red-700" (click)="delete()">
            Delete
        </button>
        <button class="rounded bg-blue-500 py-2 px-4 font-bold text-white hover:bg-blue-700" (click)="newRep()">
            New Rep
        </button>
    </div>
</div>
----

chapters/ch04-gym-diary/src/app/diary/entry-item/entry-item.ts::
+
[source, typescript]
----
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { ExerciseSet } from '../interfaces/exercise-set';
import { DatePipe } from '@angular/common';

@Component({
  selector: 'app-entry-item',
  imports: [DatePipe],
  templateUrl: './entry-item.html',
  styleUrl: './entry-item.css',
})
export class EntryItem {
  @Input('exercise-set') exerciseSet!: ExerciseSet;

  @Output() newRepEvent = new EventEmitter<ExerciseSet>();
  @Output() deleteEvent = new EventEmitter<string>();

  delete() {
    this.deleteEvent.emit(this.exerciseSet.id);
  }

  newRep() {
    const reps = ++this.exerciseSet.reps;
    const newItem: ExerciseSet = {
      ...this.exerciseSet,
      reps,
    };
    this.newRepEvent.emit(newItem);
  }
}

----

chapters/ch04-gym-diary/src/app/diary/new-item-button/new-item-button.html::
+
[source, html]
----
<button class="rounded bg-blue-500 py-2 px-4 font-bold text-white hover:bg-blue-700" (click)="addNewExercise()">Add new
    entry</button>
----

chapters/ch04-gym-diary/src/app/diary/new-item-button/new-item-button.ts::
+
[source, typescript]
----
import { Component, EventEmitter, Output } from '@angular/core';
import { ExerciseSet } from '../interfaces/exercise-set';

@Component({
  selector: 'app-new-item-button',
  imports: [],
  templateUrl: './new-item-button.html',
  styleUrl: './new-item-button.css',
})
export class NewItemButton {
  @Output() newExerciseEvent = new EventEmitter<ExerciseSet>();

  addNewExercise() {
    const id = Date.now().toString();
    const date = new Date();
    const reps = 10;
    const sets = 4;
    const exercise = 'Leg Press';
    const newExerciseSet: ExerciseSet = {
      id, date, reps, sets, exercise
    };
    this.newExerciseEvent.emit(newExerciseSet);
  }
}

----
====
======

=== Defining an error page
[tabs]
======

Calaculator Example::

Gym Diary::
+
In our current project, if the user enters a path that does not have a mapped route, they will be faced 
with a blank screen. This is not a good user experience (UX) practice; ideally, we need to handle this 
error by presenting an error page for it to be redirected to the correct page. First, let’s create the component using the Angular CLI:
+
ng generate component ErrorPage
+
Here, we are creating the component directly in AppModule because we want to give this treatment 
to our entire system and not to a specific functional module.
+
The next step is to update the AppRoutingModule routes file
+
[tabs]
====
src/app/error-page/error-page.html::
+
[source, html]
----
<div class="flex h-screen flex-col items-center justify-center">
    <h1 class="mb-4 text-6xl font-bold text-red-500">Oops!</h1>
    <h2 class="mb-2 text-3xl font-bold text-gray-800">Looks like you're lost!</h2>
    <p class="mb-6 text-gray-600">
        We couldn't find the page you're looking for.
    </p>
    <p class="text-gray-600">
        But don't worry! Go back to the Gym Diary and continue your progress!
    </p>
    <a routerLink="/home" class="mt-4 rounded bg-blue-500 px-4 py-2 font-bold text-white hover:bg-blue-600">
        Go back to the Gym Diary
    </a>
</div>
----

src/app/app.routes.ts::
+
[source, ts]
----
import { Routes } from '@angular/router';
import { Diary } from './diary/diary/diary';
import { NewEntryFormTemplate } from './diary/new-entry-form-template/new-entry-form-template';
import { NewEntryFormReactive } from './diary/new-entry-form-reactive/new-entry-form-reactive';
import { HomeComponent } from './home/home/home.component';
import { ErrorPage } from './error-page/error-page';

export const routes: Routes = [
    { path: '', pathMatch: 'full', redirectTo: 'home', },
    {
        path: 'home',
        component: HomeComponent,
    },
    {
        path: 'diary',
        component: Diary,
    },
    {
        path: 'diary/entry',
        component: NewEntryFormReactive,
    },
    { path: 'error', component: ErrorPage },
    { path: '**', redirectTo: '/error' },
];

----
====
======

=== Defining Tite page
we can use Angular’s routing mechanisms. we need to change the following code snippet:
[source,ts,attributes]
----
const routes: Routes = [
 {
 path: '',
 component: DiaryComponent,
 title: 'Diary',
 },
 {
 path: 'new-template',
 component: NewEntryFormTemplateComponent,
 },
 {
 path: 'new-reactive',
 component: NewEntryFormReactiveComponent,
 title: 'Entry Form',
 },
];
----
To change the title, we just need to inform the title property in the route definition

=== using the TrackBy property
The TrackBy attribute, in addition to avoiding unnecessary rendering, has the following advantages:

• Enables animations when removing and adding items from the collection
• Retains any DOM-specific UI state, such as focus and text selection, when the collection changes

=== Optimizing the experience using Resolve
we can increase perceived perception that your user will have may. We can load the information that our page will require before it renders and, for that, we 
will use the Resolve route saver resource.

export const diaryResolver: ResolveFn<ExerciseSetListAPI> = (route, state) => {
  const exerciseSetsService = inject(ExerciseSetsService);
  return exerciseSetsService.getInitialList();
};

{
 path: '',
 component: DiaryComponent,
 title: 'Diary',
 resolve: { diaryApi: diaryResolver },
},

. . .
private route = inject(ActivatedRoute);
. . .
 ngOnInit(): void {
 this.route.data.subscribe(({ diaryApi }) => {
 this.exerciseList = diaryApi.items;
 });
 }
. . .

When we run our project again, we see that the behavior of the screen does not change externally; 
however, internally, we are fetching information from the gym diary before the component is loaded. 
This change in our example may have been imperceptible, but in a larger and more complex application, 
it could be the difference that you and your team are looking for.

It is important to bear in mind that this will not speed up the request to the backend. It will take the 
same time as before, but the performance perception that your user will have may be impacted.

=== Improving Backend Integrations: the Interceptor Pattern
Angular Interceptor, which is a service of a specific type to handle the HTTP request flow. This 
component is based on the design pattern of the same name, which aims to change a processing cycle.

==== Authetication

suupose we have AuthService service:
[source,typescript,attributes]
----
export class AuthService {
 private httpClient = inject(HttpClient);
 private url = 'http://localhost:3000/auth/login';
 #token?: Token;
 login(loginForm: Partial<LoginForm>): Observable<Token> {
 return this.httpClient
 .post<Token>(this.url, loginForm)
 .pipe(tap((token) => (this.#token = token)));
 }
 get isLogged() {
  return this.#token ? true : false;
 }
 logout() {
 this.#token = undefined;
 }
 get token() {
 return this.#token?.access_token;
 }}
----
and we have ExerciseSetsService service to send the token in the request that returns the diary items:
[source,typescript,attributes]
----
private authService = inject(AuthService);
private url = 'http://localhost:3000/diary';
getInitialList(): Observable<ExerciseSetListAPI> {
 const headers = new HttpHeaders({
 Authorization: `Bearer ${this.authService.token}`,
 });
 return this.httpClient.get<ExerciseSetListAPI>(this.url, { headers 
});
}
----
Here, we create a header using the accessory class of Angular, HttpHeaders, passing the token 
in the Authorization attribute. Then, we pass this header in the get method of Angular’s 
HttpClient service.

This approach has a problem, as we would need to replicate this operation for all of the service’s 
methods, and as our application grows, we would need to remember to do this token handling.
A good software architecture should think about new team members with different backgrounds and 
even the creation of new teams as the project grows. Therefore, this type of transversal requirement 
of our system must be treated in a more intelligent way.

in the interceptor pattern, we have an Angular service in the middle of the request that can change both the 
request and the return from the backend.
[source,typescript,attributes]
----
import { Injectable, inject } from '@angular/core';
import {
    HttpRequest,
    HttpHandler,
    HttpEvent,
    HttpInterceptor,
    HttpHeaders,
} from '@angular/common/http';
import { Observable } from 'rxjs';
import { AuthService } from './auth';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
    private authService = inject(AuthService);

    intercept(
        request: HttpRequest<unknown>,
        next: HttpHandler
    ): Observable<HttpEvent<unknown>> {
        const token = this.authService.token;

        if (request.url.includes('auth')) {
            return next.handle(request);
        }

        if (token) {
            const reqAuth = request.clone({
                headers: request.headers.set(`Authorization`, `Bearer ${token}`),
            });
            return next.handle(reqAuth);
        }

        return next.handle(request);
    }
}
----
The first thing we can notice is that the interceptor is a common Angular service, so it has the 
@Injectable notation>

This service implements the HttpInterceptor interface, which requires the class to have the 
inject method. This method receives the request we want to handle and expects an observable as 
a return. This signature indicates the characteristic of the interceptor because this class is always in 
the middle of a flow between the component making the request and the backend.

Therefore, the service receives information from the flow and must return the flow represented by 
the observable. In our case, we use the AuthService service to get the token. The service cannot 
attach the token to the login endpoint because that is where we will get the token, so we make an if
statement by analyzing which URL the request is using.

If we have a token, we clone the request, but this time, we inform the header with the token. The 
reason we need to use the clone method to get a new object is that the request object is immutable – that is, it is not possible to change it; we need to create a new one, identical to the old one, but this 
time, we put the header.

Finally, the flow is returned but, this time, with the new request object. To configure the interceptor, 
[source,typescript,attributes]
----
export const appConfig: ApplicationConfig = {
  providers: [
    provideBrowserGlobalErrorListeners(),
    provideZonelessChangeDetection(),
    provideRouter(routes, withComponentInputBinding()),
    provideHttpClient(),
    {
      provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi:
        true
    }
  ]
};
----
We’re including the AuthInterceptor service in the HTTP_INTERCEPTORS token. This tells 
the framework to call the service whenever a component uses Angular’s HttpClient service. The 
multi attribute informs the framework that we can have more than one interceptor because, by 
default, Angular adds only one.

==== Changing the request route
[source,typescript,attributes]
----
@Injectable()
export class HostInterceptor implements HttpInterceptor {
 intercept(
 request: HttpRequest<unknown>,
 next: HttpHandler
 ): Observable<HttpEvent<unknown>> {
 const url = 'http://localhost:3000';
 const resource = request.url;
 if (request.url.includes('http')) {
 return next.handle(request);
 }
 const urlsReq = request.clone({
 url: `${url}/${resource}`,
 });
 return next.handle(urlsReq);
 }}
----
In this function, we have the URL of the backend and, in the resource variable, we receive the 
original URL of the request that we want to intercept and modify. We use an if statement next because 
we want to avoid errors in case some service needs to call another API directly.
Finally, we create a new request object (this time, with the URL changed) and we pass this new object to 
the request flow. For this interceptor to be triggered by Angular, we need to add it to the providers
array
[source,typescript,attributes]
----
export const appConfig: ApplicationConfig = {
  providers: [
    provideBrowserGlobalErrorListeners(),
    provideZonelessChangeDetection(),
    provideRouter(routes, withComponentInputBinding()),
    provideHttpClient(),
    {
      provide: HTTP_INTERCEPTORS, useClass: HostInterceptor, multi:
        true
    }
  ]
};
----
We will refactor our service to only care about the features they need, starting with the 
[source,typescript,attributes]
----
ExerciseSetsService service:
export class ExerciseSetsService {
 private httpClient = inject(HttpClient);
 private url = 'diary';
 . . .
}
----
We can see that if we needed new services or changed the URL, the HTTP requests would not need 
to be refactored, as we created an interceptor to work on that.

==== Creating a loader
In a frontend project, performance is not only about having faster requests but also improving the 
user’s perception of the application. A blank screen without any feedback signals to the user that the 
page did not load, that their internet is having a problem, or any other type of negative perception.
That’s why we always need to signal that the action the user expects is being performed. One way to 
show this is a loading indicator

we may not notice the loading screen. However, for these cases, we can use a Chrome feature that simulates a slow 3G network.
Open Chrome DevTools and, in the Network tab, use the throttling option
[tabs]
======

Calaculator Example::
+
[tabs]
====

Country.ts::
+
[source, javascript]
----
----
====

Gym Diary::
In the command line of our operating system, we will use the Angular CLI:
+
 ng generate component loading-overlay
 ng generate service loading-overlay/load
 ng generate interceptor loading-overlay/load
+
With that, we created the overlay component, the service that will control the loading state, and 
the interceptor that will control the beginning and end of the loading based on HTTP requests.
+
We will implement the LoadService service, which will maintain and control the loading state:
+
We create two methods to turn the loading state on and off and a property to expose this state.
+
The intercept method starts by turning on the loading state and returning requests without
modifying anything in them.
However, in the flow of the request, we placed the finalize operator from RxJs, which has the 
characteristic of executing a function when an observable arrives in the complete state – here, turning 
off the loading state.
+
We want the overlay to be executed in the application as a whole, so we will include the overlay component in the AppComponent component.
+
We just need to inject the LoadService service because that’s where we’ll have the loading state.
+
Finally, let’s place the overlay component in the HTML template:
[tabs]
====
frontend/src/app/loader/loader.service.ts::
[source, typescript]
----
import { Injectable, signal, Signal } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class LoaderService {
  private _isLoading = signal(false);

  showLoader() {
    this._isLoading.set(true);
  }

  hideLoader() {
    this._isLoading.set(false);
  }

  get isLoading(): Signal<boolean> {
    return this._isLoading;
  }
}

----

frontend/src/app/loader/loader-interceptor.ts::
[source, typescript]
----
import { HttpInterceptorFn } from '@angular/common/http';
import { LoaderService } from './loader.service';
import { inject } from '@angular/core';
import { finalize } from 'rxjs/operators';

export const loaderInterceptor: HttpInterceptorFn = (req, next) => {
  let loadService = inject(LoaderService);

  if (req.headers.get('X-LOADING') === 'false') {
    return next(req);
  }

  loadService.showLoader();
  return next(req)
    .pipe(finalize(() => loadService.hideLoader()));
    
};
----

frontend/src/app/loader/loading-overlay/loading-overlay::
[source, html]
----
<div class="fixed inset-0 flex items-center justify-center bg-gray-800 bg-opacity-75 z-50">
  <div class="text-white text-xl">Loading...</div>
</div>
----

[source, typescript]
----
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-loading-overlay',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './loading-overlay.html',
  styleUrls: ['./loading-overlay.css'],
})
export class LoadingOverlay {}

----

frontend/src/app::
[source, html]
----
  <main class="flex-1 bg-gray-200 p-4">
    <app-loading-overlay *ngIf="loadService.isLoading()"></app-loading-overlay>
    <router-outlet></router-outlet>
  </main>
----

[source, typescript]
----
import { Component, inject, signal } from '@angular/core';
import { RouterOutlet, RouterLink, Router } from '@angular/router';
import { AuthService } from './login/services/auth';
import { LoaderService } from './loader/loader.service';
import { LoadingOverlay } from "./loader/loading-overlay/loading-overlay";
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet, RouterLink, LoadingOverlay,CommonModule],
  templateUrl: './app.html',
  styleUrls: ['./app.css'],
})
export class App {
  private authService = inject(AuthService);
  private router = inject(Router);
  
  loadService = inject(LoaderService);

  logout() {
    this.authService.logout();
    this.router.navigate(['./login']);
  }
}

----

[source, typescript]
----
export const appConfig: ApplicationConfig = {
  providers: [
    provideBrowserGlobalErrorListeners(),
    provideZonelessChangeDetection(),
    provideRouter(routes, withComponentInputBinding()),
    provideHttpClient(withInterceptorsFromDi(), withInterceptors([loaderInterceptor])),
    {
      provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi:
        true
    },
  ]
----
====

======
== Anti-Patterns
=== Avoiding single module app
Problem: Avoid having single-module app(AppModule), The problems we have here are as follows:
* Disorganized folder structure: The team will soon not know which components belong to 
which area of the project. As the project grows, this file will get bigger and more confusing.
• Bundle size and build time: Angular has several build and bundle optimizations that depend 
on the definition of application modules. Staying in just one module, these optimizations are 
not very effective.
• Component maintainability and update issues: As this file grows, the team will have difficulties 
deprecating no longer used components or updating those components where the Angular CLI 
is unable to update automatically.

Solution: The solution to this anti-pattern is to apply separating modules into business domain (or feature) and component modules. We can use NgModel to reduce the repetition of importing common components in the application, see Optimizing the usage of common modules – the SharedModule pattern above
