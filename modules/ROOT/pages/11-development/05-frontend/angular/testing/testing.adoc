= Angular Testing

Angular provides built-in support for testing, making it easy to write and execute tests for Angular 
applications. The Angular testing framework provides a set of tools and features that make it easy to 
write unit tests, integration tests, and end-to-end tests for Angular applications. These tests can be run 
automatically as part of the build process, ensuring that the application is always tested and reliable.

TDD plays a critical role in Angular development. By writing tests first, developers can ensure that 
the code is correct and meets the requirements defined in the tests. This ensures that the application 
is reliable and reduces the risk of bugs and errors. TDD also encourages developers to write clean, 
maintainable code that is easy to modify and extend, making it easier to maintain and update the 
application over time.

== Best practices for TDD in Angular projects
Test-driven development (TDD) in Angular is a methodology that emphasizes writing tests before 
the actual implementation code. This approach ensures that code is thoroughly tested and meets 
specified requirements. In the fast-changing landscape of frontend development, where frameworks 
such as Angular enable complex enterprise-level applications to be built, the importance of good 
testing cannot be overstated. TDD results in high-quality production code and a robust code base, 
ensuring that the application works as expected and can stand the test of time.
Angular developers often find themselves navigating the intricacies of unit testing, particularly when 
dealing with components, services, and pipes. The process of writing unit tests for Angular applications 
involves understanding the structure of Angular unit tests, the need for a dummy module for testing, 
and the iterative process of building an Angular service using TDD. This iterative process, in which 
developers alternate between writing tests and the smallest amount of code necessary to pass the test, 
is the cornerstone of TDD. It allows functionality to be built in small, verifiable increments, ensuring 
that each piece of functionality is thoroughly tested.
To implement TDD effectively in Angular, developers need to be aware of common pitfalls, such as 
writing tests that are too dependent on implementation details. This can lead to brittle tests that break 
with each refactoring, even if the external behavior remains consistent. By focusing on the desired 
behavior rather than the specific implementation, developers can write clear, precise expectations that 
guide the development process. In addition, the iterative process of writing tests and code implementation 
helps to build functionality in small, verifiable increments, leading to a comprehensive test suite that 
articulates the responsibilities and expected behaviors of the system’s parts.

TDD is a methodology that prioritizes test creation before implementation coding. This strategy ensures 
that code is thoroughly tested and aligned with defined requirements. 

Here are some recommended practices and models for implementing TDD in Angular:

* Writing tests before implementation: Start by writing a test for a feature or functionality that 
doesn’t exist yet. This test will initially fail because the feature hasn’t been implemented yet. The 
test should focus on the desired behavior rather than the specific implementation, ensuring 
that the test is clear and concise.
* Use TestBed to test Angular services: Angular services are injectable classes that contain 
business logic. Testing these services is crucial to ensuring the functionality of your application. 
Use TestBed.configureTestingModule to create a mock module for testing, and 
TestBed.inject to initialize the service in this module. This configuration ensures that 
the service is isolated from external dependencies, enabling accurate testing.
* Avoid implementation details in tests: Tests should verify the behavior of a feature from the 
perspective of an end user or an API consumer, without assuming knowledge about the internal 
workings of the feature. This approach helps in creating tests that are resilient to changes in 
the implementation.
* Iterate between writing tests and implementation: Toggle between writing tests and the smallest 
amount of code necessary to pass the test. This iterative process helps in building functionality 
in small, verifiable increments, ensuring that each piece of functionality is tested thoroughly.
* Use mocks, spies, and stubs: To ensure that tests are not coupled with external dependencies, 
use mocks, spies, and stubs. Mocks provide controlled replacement implementations for 
dependencies, spies track function calls, and stubs offer predetermined behavior. These tools 
help in isolating the component or service being tested from external factors.
* Test component interactions and state management: For components, test both internal 
state changes and interactions with global state stores. Use RouterTestingModule to 
simulate navigation events and verify that components react to route changes as expected. For 
interactions between components, simulate scenarios where components communicate via 
inputs and outputs using TestBed.
* Maintain and refactor tests: Regularly review and refactor tests to ensure they remain relevant 
and reflective of the current state of the application. Refactor tests in tandem with the application 
code, ensuring that tests undergo the same rigor of improvement as your production code. 
Use version control strategies that include test updates as part of the feature branch to catch 
breaking changes early.
* Optimize test performance: Optimize the performance of your unit tests by grouping tests 
logically, using debounce and throttle techniques where applicable, and efficiently handling 
dependencies. Utilize Angular’s hierarchical injector to provide service mocks at the right level, 
reducing redundancy across tests. Regularly audit the test suite to remove obsolete tests and 
refactor those that can be merged or simplified.
* Architect resilient Angular unit tests: Design your tests to be independent of implementation 
details, focusing on the component or service’s public API. Use beforeEach() blocks 
effectively to set up the necessary conditions for each test without side effects on other tests. Write 
tests that allow components or services to expand according to the application’s requirements 
without necessitating constant test rewrites.
* Continuous improvement: Continuously refine both production and test code bases, ensuring 
that your tests are as maintainable and efficient as the features they validate. Reflect on how your 
tests might need to adapt to your business logic correctly to represent the evolving application, 
ensuring your tests remain robust and representative.

== TDD patterns 
Exploring patterns for implementing TDD in Angular projects is a critical step toward ensuring the 
robustness and reliability of your applications. TDD is a methodology that involves writing tests before 
the actual implementation code, ensuring that the code is thoroughly tested and meets the specified 
requirements. This approach not only leads to high-quality production code but also fosters a culture 
of continuous improvement and resilience against changes.

TDD patterns are strategies or approaches to implementing TDD within the context of Angular projects. 
These patterns can vary based on the specific needs of the project, the complexity of the application, 
and the team’s familiarity with TDD practices. Some of the most common TDD patterns are as follows:

* *Unit testing*: This pattern focuses on testing individual components or services in isolation. 
It is essential as it ensures that each part of your application functions as expected in isolation 
from the rest of the system.
* *Component testing*: Angular applications are built around components, making them a 
fundamental part of the user interface. When implementing TDD in Angular projects, starting 
with testing components ensures that they render correctly, handle user interactions, and 
update the UI as expected.
* *Service testing*: Services in Angular encapsulate business logic and data manipulation functions. 
Writing tests for services ensures that they perform their intended functions, interact correctly 
with external resources, and handle errors gracefully.
* *Integration testing*: This pattern involves testing the interaction between different parts of 
the application, such as components and services. It helps in identifying issues that may arise 
when different parts of the application work together.
* *End-to-end (E2E) testing*: This pattern simulates user interactions with the application in a 
real-world scenario, testing the entire application flow from start to finish. It is crucial as it 
ensures that the application behaves as expected from the user’s perspective.

Choosing a TDD pattern for your Angular project depends on several factors:

* Project complexity: For complex applications with numerous components and services, a 
combination of unit, integration, and E2E testing patterns may be necessary. This approach 
ensures that each part of the application is thoroughly tested in isolation, as well as in the 
context of the entire application.
* Team expertise: The team’s familiarity with TDD practices and the specific testing tools and 
frameworks available for Angular can influence the choice of TDD pattern. For example, Angular 
provides robust testing tools and libraries that facilitate both unit and integration testing.
* Project requirements: The specific requirements of your project, such as performance, security, 
and user experience, can also guide the choice of TDD pattern. For instance, E2E testing is 
particularly useful for projects that require a high level of user interaction and real-world testing.

== files related to writing tests

=== *.spec.ts files
*.spec.ts files contain the actual test cases that will be run against your code. These files are the 
backbone of testing in Angular as they define the individual test cases that will ensure your code 
works as expected. 

The name of the file should match the name of the file being tested, and it should 
be located in the same directory as the file being tested. 

The tests in these files are organized into test 
suites, which are defined using the describe() function. Each test case is defined using the it()
function. For example, if you were testing a component named MyComponent, you would create a 
file named my-component.spec.ts and define the test cases for that component within that file.

The describe() function is used to group related test cases together, and it takes two parameters: a 
string that describes the test suite and a function that defines the test cases within that suite. 

The it()
function is used to define individual test cases, and it takes two parameters: a string that describes the 
test case and a function that contains the code for the test case. Within the test case function, you can 
use the expect() function to define the expected behavior of your code. For example, you might 
use expect(component.title).toEqual('My Title') to test that the title property 
of a component has the expected value.

*.spec.ts files also typically import the component or service being tested, as well as any necessary 
dependencies. For example, if you were testing a component that used the HttpClient service, you 
would need to import both the component and HttpClientTestingModule from @angular/
common/http/testing.

[source,typescript,attributes]
----
import { provideZonelessChangeDetection } from '@angular/core';
import { TestBed } from '@angular/core/testing';
import { App } from './app';

describe('App', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [App],
      providers: [provideZonelessChangeDetection()]
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(App);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(App);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, getting-started-angular-tdd');
  });
});
----


=== The karma.conf.js file
The karma.conf.js file is used to configure the Karma test runner, which is used to run your 
test cases. Karma is a popular test runner for Angular applications, and it provides a simple way to 
run your tests in a variety of browsers. The karma.conf.js file specifies the files that should be 
included in the test run, as well as the browsers that should be used to run the tests.

The karma.conf.js file typically exports a configuration object that specifies these settings. The 
configuration object contains several properties, such as frameworks, files, reporters, and browsers. 
These properties allow you to configure various aspects of the test run, such as which testing framework 
to use, which files to include in the test run, which reporters to use to display test results, and which 
browsers to use to run the tests.

For example, a typical karma.conf.js file might look like this:
[source,typescript,attributes]
----
// Karma configuration file, see link for more information
// https://karma-runner.github.io/1.0/config/configuration-file.html

module.exports = function (config) {
  config.set({
    basePath: '',
    frameworks: ['jasmine'],
    plugins: [
      require('karma-jasmine'),
      require('karma-chrome-launcher'),
      require('karma-jasmine-html-reporter'),
      require('karma-coverage'),
    ],
    client: {
      jasmine: {
        // you can add configuration options for Jasmine here
        // the possible options are listed at https://jasmine.github.io/api/edge/Configuration.html
        // for example, you can disable the random execution with `random: false`
        // or set a specific seed with `seed: 4321`
      },
    },
    jasmineHtmlReporter: {
      suppressAll: true // removes the duplicated traces
    },
    coverageReporter: {
      dir: require('path').join(__dirname, './coverage/getting-started-angular-tdd'),
      subdir: '.',
      reporters: [
        { type: 'html' },
        { type: 'text-summary' }
      ]
    },
    reporters: ['progress', 'kjhtml'],
    browsers: ['firefox'],
    restartOnFileChange: true
  });
};
----

=== The tsconfig.spec.json file
The tsconfig.spec.json file is used to configure the TypeScript compiler for your test cases. 
It specifies the compiler options that should be used when compiling your test files. This file typically 
extends the main tsconfig.json file for your project but may include additional settings specific 
to testing.
[source,typescript,attributes]
----
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/spec",
    "types": [
      "jasmine"
    ]
  },
  "include": [
    "src/**/*.ts"
  ]
}
----
This file extends the main tsconfig.json file and specifies the compiler options that should be 
used for test files.

== Jasmine
Jasmine is a behavior-driven development (BDD) framework for testing JavaScript code. It provides 
a simple and readable syntax for writing tests, making it easier to understand and maintain the code. 
With Jasmine, developers can define test suites and test cases, and then use various matchers to check 
the expected behavior of their code.

== Karma
Karma, on the other hand, is a test runner that allows developers to execute their tests in multiple 
browsers and environments. It provides a seamless integration with Jasmine, allowing developers to 
easily run their Jasmine tests in different browsers and get real-time feedback on the test results. Karma 
also offers additional features, such as code coverage reporting and continuous integration support.
Using Jasmine and Karma together can greatly enhance the testing process for Angular applications. 
Developers can write comprehensive test suites using Jasmine’s expressive syntax, and then use Karma 
to run these tests in various browsers, ensuring compatibility across different environments. This 
helps catch any potential issues or bugs early on and promotes a more robust and reliable application.

== Writing your first unit tests in an Angular project
Create a new component called CalculatorComponent by running the following command:

 ng g c calculator

After creating the component with the preceding command line, a calculator.component.
spec.ts file will be created in the src/ app/calculator folder. When you open the 
file, you’ll see the following code by default:
[source,javascript,attributes]
----
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { Calculator } from './calculator';

describe('Calculator', () => {
  let component: Calculator;
  let fixture: ComponentFixture<Calculator>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [Calculator]
    })
    .compileComponents();

    fixture = TestBed.createComponent(Calculator);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
----
In the preceding generated code, we have a test suite where we have used the describe
function, providing a descriptive name for the component under test. Within the test 
suite, we have a beforeEach block to set up the test environment. The TestBed.
configureTestingModule method is used to configure the test module and provide 
the necessary dependencies. The calculator variable is then assigned to an instance of 
CalculatorComponent using the TestBed.inject method.

CalculatorComponent component will enable us to perform basic arithmetic 
operations. To write a unit test using TDD, we’ll start by creating a test case that verifies the 
component’s expected behavior.

Now, we’ll write the actual test case using the it function. In this case, we’ll test the add
method of CalculatorComponent by passing it two numbers and expecting the result to 
be 5. The expect function is used to define the expected behavior and check the actual result. 
The following code must be added to the test suite – that is, inside the describe function:
[source,javascript,attributes]
----
  it('should add two numbers correctly', () => {
    const result = component.add(2, 3);
    expect(result).toBe(5)
  });
----
This is normal as it hasn’t been created yet.
Upon returning to our Karma server, we’ll see that our test case isn’t displayed in 
CalculatorComponent and that in the terminal, we have an error related to the non-existence 
of the function and a message indicating that no test has succeeded.

Next, we will implement the add function in calculator.component.ts. Having 
defined our first test case, we can proceed to implement calculator.component.ts for 
the test to pass. Following the TDD approach, write the minimum amount of code necessary 
to pass the tests:
[source,javascript,attributes]
----
  add(a: number, b: number) {
    return a + b;
  }
----
Once the tests have passed, you can refactor the code to improve its design, readability, and maintainability. 
Refactoring is an essential step in the TDD process as it helps eliminate duplication and improves 
code structure and overall quality. It is essential to ensure that tests continue to run after refactoring. 
Regularly reviewing and updating tests as the code base evolves will help maintain the integrity and 
reliability of unit tests.

== Code coverage and test result analysis with Karma
Code coverage and test result analysis are essential aspects of the software development process. By 
measuring code coverage, developers can assess the effectiveness of their unit tests and identify areas 
that require additional testing. Karma, a popular testing framework in the JavaScript ecosystem, 
provides built-in support for code coverage and test result analysis. 

Code coverage and test result analysis are essential aspects of the software development process. By 
measuring code coverage, developers can assess the effectiveness of their unit tests and identify areas 
that require additional testing. Karma, a popular testing framework in the JavaScript ecosystem, 
provides built-in support for code coverage and test result analysis. In this section, we’ll learn how 
to leverage Karma to measure code coverage, generate detailed reports, and analyze test results. By 
utilizing these features, developers can ensure comprehensive testing and improve the overall quality 
and reliability of their code.

Here are the different steps Angular performs for us:

1. Step 1 – setting up Karma with code coverage:
To utilize code coverage with Karma, start by installing the necessary dependencies:
  npm install --save-dev karma-coverage
2. Step 2 – Next, configure Karma to generate code coverage reports. Update your Karma configuration 
file (karma.conf.js) with the following changes:
[source,json,attributes]
----
    coverageReporter: {
      dir: require('path').join(__dirname, './coverage/getting-started-angular-tdd'),
      subdir: '.',
      reporters: [
        { type: 'html' },
        { type: 'text-summary' }
      ]
    },
    reporters: ['progress', 'kjhtml'],
----
This configuration specifies the reporters to be used (progress for test progress and coverage
for code coverage). The coverageReporter section defines the output directory and the 
types of reports to generate (HTML and Text Summary).
3. Step 3 – running tests and generating code coverage reports:
+
After configuring Karma for code coverage, run your tests as usual. Karma will now generate 
code coverage reports alongside the test results. These coverage reports provide insights into 
which parts of your code base are covered by tests and which areas require additional testing.
+
Once the tests have finished running, navigate to the coverage directory to view the generated 
reports. Open the HTML report (coverage/report-html/index.html) in a web 
browser to visualize the code coverage details. The report highlights covered lines, uncovered 
lines, and overall coverage percentages. 
4. Step 4 – analyzing the test results:
+
Karma also offers features to analyze the test results, including test reporting and integration 
with popular continuous integration (CI) tools. By leveraging these capabilities, developers can 
gain insights into test failures, identify patterns, and track the overall health of their test suite.
Karma provides various reporters that offer different levels of detail in the test output. For 
example, mocha-reporter displays detailed information about test failures, including stack 
traces and error messages, whereas junit-reporter generates JUnit-style XML reports 
that can be consumed by CI tools for further analysis.
To integrate Karma with CI tools, configure the respective plugin or reporter in your Karma 
configuration file. For example, to generate JUnit reports for Jenkins, add the karma-junitreporter plugin and configure it accordingly.
5. Step 5 – utilizing thresholds and quality gates:
Karma allows developers to define thresholds and quality gates for code coverage and test 
results. By setting these thresholds, developers can establish the minimum requirements for 
code coverage and test success rates. This ensures that the code base maintains a certain level 
of quality and reduces the risk of shipping untested or poorly covered code.
+
To set thresholds for code coverage, update your Karma configuration file as follows:
[source,javascript,attributes]
----
module.exports = function(config) {
 config.set({
 // ...
 coverageReporter: {
 // ...
 check: {
 global: {
 statements: 80,
 branches: 80,
 functions: 80,
 lines: 80
 }
 }
 },
 // ...
 });
};
----

In this example, the thresholds have been set to 80% for statements, branches, functions, and
lines. If any of these thresholds are not met, Karma will report a failed test result.

=== Code coverage visualization
Let’s run the following command in our project’s terminal:
  ng test –code-coverage

== Testing Components
=== Testing lifecycle hooks
Angular provides several lifecycle hooks that allow us to perform actions at specific stages of a component’s lifecycle. Testing these hooks ensures that our components behave as expected:

* ngOnInit(): The ngOnInit() hook is called after the component has been initialized. we can use this hook to set the initial values and perform any 
necessary setup.To test ngOnInit(), we can verify whether the initial values are correctly 
set and whether any necessary setup is performed.
* ngOnChanges(): The ngOnChanges() hook is called whenever there are changes to 
the component’s input properties. we can use this hook to 
update the component state based on the changes. To test ngOnChanges(), we can simulate 
changes to the input properties and verify whether the component state is updated accordingly.
* ngOnDestroy(): The ngOnDestroy() hook is called just before the component is 
destroyed. we can use this hook to clean up any resources 
or subscriptions. To test ngOnDestroy(), we can simulate the component destruction and 
verify whether the necessary cleanup actions are performed.
[tabs]
====
calculator.component.ts::
+
[source, javascript]
----
export class Calculator {
  result!: number;

  ngOnInit(): void {
    this.result = 0;
  }
}
----

calculator.component.spec.ts::
+
[source, javascript]
----
it('should initialize result to 0', () => {
    calculator.ngOnInit();
    expect(calculator.result).toEqual(0);
  });
----
====

== Testing Services
=== Testing methods

[tabs]
====
calculator.service.ts::
+
[source, javascript]
----
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class CalculatorService {
  private resultSubject = new BehaviorSubject<number>(0);
  public result$ = this.resultSubject.asObservable();

  constructor() { }

  add(a: number, b: number): number {
    return a + b;
  }

  substract(a: number, b: number): number {
    return a - b;
  }

  multiply(a: number, b: number): number {
    return a * b;
  }

  divide(a: number, b: number): number {
    return a / b;
  }
}
----

calculator.service.spec.ts::
+
[source, javascript]
----
import { TestBed } from '@angular/core/testing';

import { CalculatorService } from './calculator.service';
import { provideZonelessChangeDetection } from '@angular/core';

describe('Calculator', () => {
  let service: CalculatorService;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [],
      providers: [provideZonelessChangeDetection()
      ]
    })
    service = TestBed.inject(CalculatorService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
----

calculator.component.ts::
+
[source, javascript]
----
 add(a: number, b: number): void {
    this.result = this.calculatorService.add(a, b);
  }
----

calculator.component.spec.ts::
+
[source, javascript]
----
  it('should add two numbers correctly', () => {
    spyOn(calculatorService, 'add').and.callThrough();
    calculator.add(2, 3);
    expect(calculatorService.add).toHaveBeenCalledWith(2, 3);
    expect(calculator.result).toBe(5);
  });
----
====

=== Testing HTTP requests
=== Testing observables
=== Testing error handling

== Testing directives

In our current calculator application development project, we’re going to use a directive to apply a 
color to the calculation result displayed on the screen.

To handle color changes in our Angular calculator application, we’re going to create a custom directive. 
Directives allow us to extend the functionality of HTML elements and encapsulate specific behaviors.
In this case, we’ll create a directive called colorChange that will be responsible for handling color 
transitions. The directive will accept an input parameter specifying the color to be changed. It will 
then apply the CSS styles required to achieve the desired effect.

When we want to use a directive on an HTML tag that takes a property as a parameter, here’s what it looks like:
  <p [colorChange]="color"> </p>
According to the preceding code, colorChange is our directive. It takes color as a parameter. This 
implies that color is an attribute of our component. 
[tabs]
====
calculator.component.ts::
+
[source, javascript]
----
export class CalculatorComponent {
  color = 'red';
}
----

calculator.component.html::
+
[source, html]
----
<p [colorChange]="color"> {{ result }} </p>
----

color-change.directive.ts::
+
[source, javascript]
----
import { Directive, ElementRef, Input, OnInit, Renderer2 } from '@angular/core';

@Directive({
  selector: '[colorChange]',
  standalone: true
})
export class ColorChangeDirective implements OnInit {
  @Input() colorChange!: string;
  
  constructor(private elementRef: ElementRef, private renderer: Renderer2) { }

  ngOnInit() {
    this.renderer.setStyle(this.elementRef.nativeElement, 'color', this.colorChange);
  }
}

----

color-change.directive.spec.ts::
+
[source, javascript]
----
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { CalculatorComponent } from '../../calculator/calculator.component';
import { By } from '@angular/platform-browser';
import { provideZonelessChangeDetection } from '@angular/core';

describe('ColorChangeDirective', () => {
  let fixture: ComponentFixture<CalculatorComponent>;
  let calculator: CalculatorComponent;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      providers: [provideZonelessChangeDetection()
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(CalculatorComponent);
    calculator = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should apply the specified color', () => {
    const element: HTMLElement = fixture.debugElement.query(By.css('p')).nativeElement;
    const color: string = 'red';
    calculator.color = color;
    fixture.detectChanges();

    expect(element.style.color).toBe(color);
  });
});
----
====

== Monitoring and controlling dependency calls using method stubs and spies
One crucial aspect of testing in Angular applications is the ability to monitor and control dependency 
calls. Dependencies are external resources or services that a piece of code relies on to function correctly. 
Monitoring and controlling these dependency calls allows developers to ensure that their code interacts 
correctly with external systems and handles different scenarios gracefully.

Spies and method stubs are two powerful techniques within Angular’s testing framework that enable 
developers to achieve this level of control. Spies allow developers to monitor function calls, record 
information about those calls, and assert expectations about their usage. On the other hand, method 
stubs provide a way to replace real dependencies with simplified versions, allowing developers to 
control the behavior of those dependencies during testing.

By using spies, developers can verify that the correct functions are called with the right parameters 
and that they are called the expected number of times. This is particularly useful when testing code 
that interacts with external APIs or databases. 

Method stubs, on the other hand, enable developers 
to simulate different scenarios and provide predefined responses to method calls. This allows for 
thorough testing of edge cases and ensures the code’s robustness.

=== Method stubs and spies
Method stubs, also known as fake or dummy objects, are used to replace real dependencies with 
simplified versions during testing. By providing predefined responses to method calls, method 
substitutes enable developers to isolate and control the behavior of the code under test

==== Method stubs

[tabs]
====
In the calculator application, let’s consider a scenario in which the user performs a division operation 
with a divisor equal to zero. We want to make sure that the application handles this scenario correctly. 
By creating a method plug for the divide function, we can simulate the divide-by-zero scenario and 
check that the application displays an appropriate error message.
+
[source,javascript,attributes]
----
  it('should raise an exception when dividing by zero', () => {
    spyOn(calculatorService, 'divide').and.callThrough();

    expect(() => calculator.divide(10, 0))
      .toThrowError('Cannot divide by zero');

    expect(calculatorService.divide).toHaveBeenCalledWith(10, 0);
  });
----
+
At present, our calculator’s division operation does not handle the exception related to division by zero.
In our calculator.component.spec.ts test file, we’re going to add the test that allows us to 
raise this exception. Since we’re following TDD principles, the test should fail naturally
+
To correct this, we need to update our CalculatorService. In our present scenario, there’s a 
clever approach to refrain from direct interaction with our core service and ensure that everything is 
operational prior to any such action. This approach involves the utilization of a method stub concept.
+
Basically, we’ll point our CalculatorService service at a fake service that will enable us to 
check the correctness of the logic we want to implement before modifying the service itself. In 
fact, this fake service will simply be a stub method that replaces the classic division of our basic 
CalculatorService service. 
+
we’ll declare this stub method:
+
[source,javascript,attributes]
----
const calculatorServiceStub = {
  divide: (a: number, b: number) => {
    if (b === 0) {
      throw new Error('Cannot divide by zero');
    }
    return a / b;
  },
};
----
+
Then, in the describe method, within the configureTestingModule method, we will replace 
our CalculatorService provider with the following:
[source,javascript,attributes]
----
  providers: [provideZonelessChangeDetection(),
  {
    provide: CalculatorService, useValue: calculatorServiceStub
  }
----

CalculatorServiceStub::
+
[source, javascript]
----
export class CalculatorServiceStub {
    add(a: number, b: number): number {
        return a + b;
    }

    substract(a: number, b: number): number {
        return a - b;
    }

    multiply(a: number, b: number): number {
        return a * b;
    }

    divide(a: number, b: number): number | Error {
        if (b === 0) {
            throw new Error('Cannot divide by zero');
        }
        return a / b;
    }
}
----

calculator.component.spec.ts::
+
[source, javascript]
----
describe('CalculatorComponentUsingCalculatorServiceStubService', () => {
  let calculator: CalculatorComponent;
  let fixture: ComponentFixture<CalculatorComponent>;
  let calculatorService: CalculatorService;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [CalculatorComponent, ColorChangeDirective],
      providers: [provideZonelessChangeDetection(),
      {
        provide: CalculatorService, useClass: CalculatorServiceStub
      }
      ]
    })
      .compileComponents();

    fixture = TestBed.createComponent(CalculatorComponent);
    calculator = fixture.componentInstance;
    calculatorService = TestBed.inject(CalculatorService);
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(calculator).toBeTruthy();
  });

  it('should initialize result to 0', () => {
    calculator.ngOnInit();
    expect(calculator.result).toEqual(0);
  });

  it('should add two numbers correctly', () => {
    spyOn(calculatorService, 'add').and.callThrough();
    calculator.add(2, 3);
    expect(calculatorService.add).toHaveBeenCalledWith(2, 3);
    expect(calculator.result).toBe(5);
  });

  it('should substract two numbers correctly', () => {
    spyOn(calculatorService, 'substract').and.callThrough();
    calculator.substract(2, 3);
    expect(calculatorService.substract).toHaveBeenCalledWith(2, 3);
    expect(calculator.result).toBe(-1);
  });

  it('should multiply two numbers correctly', () => {
    spyOn(calculatorService, 'multiply').and.callThrough();
    calculator.multiply(2, 3);
    expect(calculatorService.multiply).toHaveBeenCalledWith(2, 3);
    expect(calculator.result).toBe(6);
  });

  it('should divide two numbers correctly', () => {
    spyOn(calculatorService, 'divide').and.callThrough();
    calculator.divide(4, 2);
    expect(calculatorService.divide).toHaveBeenCalledWith(4, 2);
    expect(calculator.result).toBe(2);
  });

  it('should raise an exception when dividing by zero', () => {
    spyOn(calculatorService, 'divide').and.callThrough();

    expect(() => calculator.divide(10, 0))
      .toThrowError('Cannot divide by zero');

    expect(calculatorService.divide).toHaveBeenCalledWith(10, 0);
  });
});
----
====

== Injecting mocked dependencies using TestBed providers
Mocked dependencies are simplified versions of external services or resources that mimic the behavior 
of the actual dependencies. By injecting these mocked dependencies using TestBed providers, 
developers can control their behavior during testing, ensuring reliable and thorough testing without 
relying on external systems.

TestBed providers enable developers to inject mocked dependencies 
into their code. By doing so, we can create isolated and controlled testing environments, adhering to 
the principles of TDD.

By injecting mocked dependencies using TestBed providers, developers can focus on testing specific 
units of code without worrying about the complexities of the actual dependencies. This approach 
allows for easier debugging, improved test coverage, and better overall code quality.

When configuring the testing module using TestBed.configureTestingModule, you can 
provide a list of providers that specify the tokens for the dependencies you want to mock. You can 
then use either the useClass or useValue property to provide a mock or stub implementation 
for each dependency.


[tabs]
======

Calaculator Example::
+
Let’s consider adding the ability to calculate the square root of a number to our calculator application, 
while still relying on our CalculatorService service. In this case, we’ll focus on the square root 
functionality of the calculator application.
+
Here’s an example of a mock square root service:
[source,javascript,attributes]
----
export class MockSquareRootService {
    calculateSquareRoot(value: number): number {
        // Perform a predefined square root calculation based on the input 
        value
        return Math.sqrt(value);
    }
}
----
+
Next, we will configure the test module using TestBed providers to replace the real square root service 
with the simulated version in calculator.component.spec.ts. Here’s an example of how 
to configure the test module:
[source,javascript,attributes]
----
import { MockSquareRootService } from './mock-square-root.service';
...
beforeEach(async () => {
 await TestBed.configureTestingModule({
 ...
 providers: [{ provide: CalculatorService, useClass: 
MockSquareRootService }]
 }).compileComponents();
----
+
This configuration tells TestBed to use the mock service whenever the code under test requests an instance of the actual square root service.
+
Now, when we run our tests for the calculator app, any code that depends on the square root service will 
receive an instance of the mocked service. We can control the behavior of the service during testing, 
ensuring that the calculator app correctly performs square root calculations under different scenarios. 
Here’s some example code for the MockSquareRootService service that mimics the behavior of 
the CalculatorService service by returning predefined square root values for different inputs:

[tabs]
====
src/app/core/mocks/mock-square-root.service.mock.ts::
+
[source, javascript]
----
export class MockSquareRootService {
    squareRoot(value: number): number {
        // Perform a predefined square root calculation based on the input value
        if (value === 4) {
            return 2;
        } else if (value === 9) {
            return 3;
        } else if (value === 16) {
            return 4;
        } else {
            throw new Error('Invalid input');
        }
    }
}
----

src/app/calculator/calculator.component.spec.ts::
+
[source, javascript]
----
describe('CalculatorComponentUsingMockSquareRootService', () => {
  let calculator: CalculatorComponent;
  let fixture: ComponentFixture<CalculatorComponent>;
  let calculatorService: CalculatorService;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [CalculatorComponent, ColorChangeDirective],
      providers: [provideZonelessChangeDetection(),
      {
        provide: CalculatorService, useClass: MockSquareRootService
      }
      ]
    })
      .compileComponents();

    fixture = TestBed.createComponent(CalculatorComponent);
    calculator = fixture.componentInstance;
    calculatorService = TestBed.inject(CalculatorService);
    fixture.detectChanges();
  });

  it('should calculate the square root correctly', () => {
    spyOn(calculatorService, 'squareRoot').and.callThrough();
    calculator.squareRoot(16);
    expect(calculatorService.squareRoot).toHaveBeenCalledWith(16);
    expect(calculator.result).toBe(4);
  });
});
----
====

Another Example::
+
[source, java]
----
----

======

== Handling async operations
`fakeAsync` This is an Angular utility function that lets you write tests that rely on asynchronous 
operations synchronously. It is useful for testing code that uses observables, promises, or other 
asynchronous operations.

[tabs]
======

Calaculator Example::
+
Let’s consider that our calculator application that performs addition, subtraction, multiplication, and 
division now has a service that performs these operations and returns the result as an observable.
+
First, let’s assume we have another calculator service called CalculatorAsyncService
+
[tabs]
====
src/app/core/services/calculater-async.ts::
+
[source, javascript]
----
import { Injectable } from '@angular/core';
import { Observable, catchError, of, throwError } from 'rxjs';

@Injectable({
  providedIn: 'root',
})
export class CalculatorAsyncService {
  constructor() { }

  add(a: number, b: number): Observable<number> {
    return of(a + b);
  }

  subtract(a: number, b: number): Observable<number> {
    return of(a - b);
  }

  multiply(a: number, b: number): Observable<number> {
    return of(a * b);
  }

  divide(a: number, b: number): Observable<number> {
    if (b === 0) {
      return throwError(() => new Error('Cannot divide by zero'));
    }
    /*
    the catchError operator is used to 
    catch any errors that may occur during the divide operation and throw them back using 
    the throwError function. This ensures that if an error occurs (other than division by zero, 
    which is explicitly handled), the observable will issue an error notification.
    */
    return of(a / b).pipe(
      catchError((error) => {
        return throwError(() => error);
      })
    );
  }
}
----

src/app/core/services/calculater-async.spec.ts::
+
[source, javascript]
----
import { TestBed } from '@angular/core/testing';

import { provideZonelessChangeDetection } from '@angular/core';
import { CalculatorAsyncService } from './calculater-async';

describe('CalculatorAsyncService', () => {
  let service: CalculatorAsyncService;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [],
      providers: [provideZonelessChangeDetection()
      ]
    })
      .compileComponents();
    service = TestBed.inject(CalculatorAsyncService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });

  it('should add two numbers', async () => {
    let result = 0;
    service.add(1, 2).subscribe((val: number) => {
      result = val;
    });
    expect(result).toBe(3);
  });

  it('should subtract two numbers', async () => {
    let result = 0;
    service.subtract(5, 3).subscribe((val: number) => {
      result = val;
    });

    expect(result).toBe(2);
  });

  it('should multiply two numbers', async () => {
    let result = 0;
    service.multiply(3, 4).subscribe((val: number) => {
      result = val;
    });

    expect(result).toBe(12);
  });

  it('should divide two numbers', async () => {
    let result = 0;
    service.divide(10, 2).subscribe((val: number) => {
      result = val;
    });

    expect(result).toBe(5);
  });

  it('should throw an error when dividing by zero', async () => {
    let error = { message: '' };
    service.divide(10, 0).subscribe({
      error: (err) => (error = err),
    });
    expect(error).toBeTruthy();
    expect(error.message).toBe('Cannot divide by zero');
  });
});
----
====

Another Example::
+
[source, java]
----
----
======

== Testing Angular pipe

[tabs]
======

Calaculator Example::
+
Our calculator application is a simple tool that performs basic arithmetic operations, including 
addition, subtraction, multiplication, and division. Let’s suppose we have a feature that allows us to 
represent a number as a percentage. To do this, we will be using a pipe. We’ll call our pipe percent.
+
Following the principles of test-driven development (TDD), we will create a test suite that includes 
the following tests:
+
* A test that formats a positive number to a percentage string
* A test that formats a negative number to a percentage string
* A test that formats a decimal number to a percentage string
* A test that formats a non-number to a percentage string
+
[tabs]
====
src/app/core/pipes/percent-pipe.ts::
+
[source, javascript]
----
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'percent'
})
export class PercentPipe implements PipeTransform {

  transform(value: number, ...args: unknown[]): string {
    if (isNaN(value)) {
      return 'Error';
    }
    const formattedValue = value * 100;
    return formattedValue + '%';
  }

}

----

src/app/core/pipes/percent-pipe.spec.ts::
+
[source, javascript]
----
import { PercentPipe } from "./percent-pipe";

describe('PercentPipe', () => {
  it('create an instance', () => {
    const pipe = new PercentPipe();
    expect(pipe).toBeTruthy();
  });

  it('should format a positive number to a percentage string', () => {
    const input = 123;
    const output = new PercentPipe().transform(input);
    expect(output).toBe('12300%');
  });

  it('should format a negative number to a percentage string', () => {
    const input = -123;
    const output = new PercentPipe().transform(input);
    expect(output).toBe('-12300%');
  });

  it('should format a decimal number to a percentage string', () => {
    const input = 123.45;
    const output = new PercentPipe().transform(input);
    expect(output).toBe('12345%');
  });

  it('should return an Error when the value is not a number NaN', () => {
    const input = NaN;
    const output = new PercentPipe().transform(input);
    expect(output).toBe('Error');
  });

});

----
====

Another Example::
+
[source, java]
----
----
======


== Testing reactive form
Testing Angular forms involves verifying that the form fields are correctly bound to the model, validating the input, and handling form submissions. By testing forms, developers can ensure that the form behaves as 
expected and provides a seamless user experience.

[tabs]
======

Calaculator Example::
+
we will discuss how to implement a reactive form user interface for our calculator app. 
We will use TDD to ensure that our form is valid and that our calculator componen
+
[tabs]
====
src/app/calculator/calculator.component.ts::
+
[source, javascript]
----
import { Component } from '@angular/core';
import { CalculatorService } from '../core/services/calculator.service';
import { ColorChangeDirective } from '../core/directives/color-change-directive';
import { PercentPipe } from '../core/pipes/percent-pipe';
import { FormControl, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';

@Component({
  selector: 'app-calculator',
  imports: [ColorChangeDirective, PercentPipe, ReactiveFormsModule],
  templateUrl: './calculator.component.html',
  styleUrl: './calculator.component.css',
  standalone: true
})
export class CalculatorComponent {

  calculatorForm!: FormGroup;


  result!: number;
  color = 'red';

  constructor(private calculatorService: CalculatorService) {
    this.calculatorForm = new FormGroup({
      operand1: new FormControl(null, [Validators.required]),
      operand2: new FormControl(null, [Validators.required]),
      operator: new FormControl(null, [Validators.required]),
    });
  }

  ngOnInit(): void {
    this.result = 0;
  }
  
  calculate(): void {
    if (this.calculatorForm.get('operator')?.value === '+') {
      this.add(
        this.calculatorForm.get('operand1')?.value,
        this.calculatorForm.get('operand2')?.value
      );
    }

    if (this.calculatorForm.get('operator')?.value === '-') {
      this.substract(
        this.calculatorForm.get('operand1')?.value,
        this.calculatorForm.get('operand2')?.value
      );
    }

    if (this.calculatorForm.get('operator')?.value === '*') {
      this.multiply(
        this.calculatorForm.get('operand1')?.value,
        this.calculatorForm.get('operand2')?.value
      );
    }

    if (this.calculatorForm.get('operator')?.value === '/') {
      this.divide(
        this.calculatorForm.get('operand1')?.value,
        this.calculatorForm.get('operand2')?.value
      );
    }
  }

  add(a: number, b: number): void {
    this.result = this.calculatorService.add(a, b);
  }

  substract(a: number, b: number): void {
    this.result = this.calculatorService.substract(a, b);
  }

  multiply(a: number, b: number): void {
    this.result = this.calculatorService.multiply(a, b);
  }

  divide(a: number, b: number): void {
    this.result = this.calculatorService.divide(a, b);
  }

  squareRoot(a: number) {
    this.result = this.calculatorService.squareRoot(a);
  }
}
----

src/app/calculator/calculator.component.spec.ts::
+
[source, javascript]
----
describe('Testing CalculatorComponent Form', () => {
  let calculator: CalculatorComponent;
  let fixture: ComponentFixture<CalculatorComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [CalculatorComponent],
      providers: [provideZonelessChangeDetection(),
        CalculatorService
      ]
    })
      .compileComponents();

    fixture = TestBed.createComponent(CalculatorComponent);
    calculator = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should be valid when all of the fields are filled in correctly',
    () => {
      calculator.calculatorForm.get('operand1')?.setValue(123);
      calculator.calculatorForm.get('operand2')?.setValue(456);
      calculator.calculatorForm.get('operator')?.setValue('+');

      expect(calculator.calculatorForm.valid).toBe(true);
    });

  it('should be invalid when one of the field is not filled in correctly', () => {
    calculator.calculatorForm.get('operand1')?.setValue(123);
    calculator.calculatorForm.get('operator')?.setValue('+');

    expect(calculator.calculatorForm.valid).toBe(false);
  });

  it('should be added when the + operator is selected and the calculate button is clicked', () => {
    calculator.calculatorForm.get('operand1')?.setValue(2);
    calculator.calculatorForm.get('operand2')?.setValue(3);
    calculator.calculatorForm.get('operator')?.setValue('+');

    calculator.calculate();
    
    expect(calculator.result).toBe(5);
  });

  it('should subtract when the - operator is selected and the calculate button is clicked', () => {
    calculator.calculatorForm.get('operand1')?.setValue(2);
    calculator.calculatorForm.get('operand2')?.setValue(3);
    calculator.calculatorForm.get('operator')?.setValue('-');

    calculator.calculate();

    expect(calculator.result).toBe(-1);
  });


  it('should multiply when the * operator is selected and the calculate button is clicked', () => {
    calculator.calculatorForm.get('operand1')?.setValue(2);
    calculator.calculatorForm.get('operand2')?.setValue(3);
    calculator.calculatorForm.get('operator')?.setValue('*');

    calculator.calculate();

    expect(calculator.result).toBe(6);
  });

  it('should divide when the / operator is selected and the calculation button is clicked.', () => {
    calculator.calculatorForm.get('operand1')?.setValue(3);
    calculator.calculatorForm.get('operand2')?.setValue(2);
    calculator.calculatorForm.get('operator')?.setValue('/');

    calculator.calculate();

    expect(calculator.result).toBe(1.5);
  });
});
----
====

Another Example::
+
[source, java]
----
----
======