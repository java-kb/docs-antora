= Angular Testing

Angular provides built-in support for testing, making it easy to write and execute tests for Angular 
applications. The Angular testing framework provides a set of tools and features that make it easy to 
write unit tests, integration tests, and end-to-end tests for Angular applications. These tests can be run 
automatically as part of the build process, ensuring that the application is always tested and reliable.

TDD plays a critical role in Angular development. By writing tests first, developers can ensure that 
the code is correct and meets the requirements defined in the tests. This ensures that the application 
is reliable and reduces the risk of bugs and errors. TDD also encourages developers to write clean, 
maintainable code that is easy to modify and extend, making it easier to maintain and update the 
application over time.

== files related to writing tests

=== *.spec.ts files
*.spec.ts files contain the actual test cases that will be run against your code. These files are the 
backbone of testing in Angular as they define the individual test cases that will ensure your code 
works as expected. 

The name of the file should match the name of the file being tested, and it should 
be located in the same directory as the file being tested. 

The tests in these files are organized into test 
suites, which are defined using the describe() function. Each test case is defined using the it()
function. For example, if you were testing a component named MyComponent, you would create a 
file named my-component.spec.ts and define the test cases for that component within that file.

The describe() function is used to group related test cases together, and it takes two parameters: a 
string that describes the test suite and a function that defines the test cases within that suite. 

The it()
function is used to define individual test cases, and it takes two parameters: a string that describes the 
test case and a function that contains the code for the test case. Within the test case function, you can 
use the expect() function to define the expected behavior of your code. For example, you might 
use expect(component.title).toEqual('My Title') to test that the title property 
of a component has the expected value.

*.spec.ts files also typically import the component or service being tested, as well as any necessary 
dependencies. For example, if you were testing a component that used the HttpClient service, you 
would need to import both the component and HttpClientTestingModule from @angular/
common/http/testing.

[source,typescript,attributes]
----
import { provideZonelessChangeDetection } from '@angular/core';
import { TestBed } from '@angular/core/testing';
import { App } from './app';

describe('App', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [App],
      providers: [provideZonelessChangeDetection()]
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(App);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(App);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, getting-started-angular-tdd');
  });
});
----


=== The karma.conf.js file
The karma.conf.js file is used to configure the Karma test runner, which is used to run your 
test cases. Karma is a popular test runner for Angular applications, and it provides a simple way to 
run your tests in a variety of browsers. The karma.conf.js file specifies the files that should be 
included in the test run, as well as the browsers that should be used to run the tests.

The karma.conf.js file typically exports a configuration object that specifies these settings. The 
configuration object contains several properties, such as frameworks, files, reporters, and browsers. 
These properties allow you to configure various aspects of the test run, such as which testing framework 
to use, which files to include in the test run, which reporters to use to display test results, and which 
browsers to use to run the tests.

For example, a typical karma.conf.js file might look like this:
[source,typescript,attributes]
----
// Karma configuration file, see link for more information
// https://karma-runner.github.io/1.0/config/configuration-file.html

module.exports = function (config) {
  config.set({
    basePath: '',
    frameworks: ['jasmine'],
    plugins: [
      require('karma-jasmine'),
      require('karma-chrome-launcher'),
      require('karma-jasmine-html-reporter'),
      require('karma-coverage'),
    ],
    client: {
      jasmine: {
        // you can add configuration options for Jasmine here
        // the possible options are listed at https://jasmine.github.io/api/edge/Configuration.html
        // for example, you can disable the random execution with `random: false`
        // or set a specific seed with `seed: 4321`
      },
    },
    jasmineHtmlReporter: {
      suppressAll: true // removes the duplicated traces
    },
    coverageReporter: {
      dir: require('path').join(__dirname, './coverage/getting-started-angular-tdd'),
      subdir: '.',
      reporters: [
        { type: 'html' },
        { type: 'text-summary' }
      ]
    },
    reporters: ['progress', 'kjhtml'],
    browsers: ['firefox'],
    restartOnFileChange: true
  });
};
----

=== The tsconfig.spec.json file
The tsconfig.spec.json file is used to configure the TypeScript compiler for your test cases. 
It specifies the compiler options that should be used when compiling your test files. This file typically 
extends the main tsconfig.json file for your project but may include additional settings specific 
to testing.
[source,typescript,attributes]
----
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/spec",
    "types": [
      "jasmine"
    ]
  },
  "include": [
    "src/**/*.ts"
  ]
}
----
This file extends the main tsconfig.json file and specifies the compiler options that should be 
used for test files.

== Jasmine
Jasmine is a behavior-driven development (BDD) framework for testing JavaScript code. It provides 
a simple and readable syntax for writing tests, making it easier to understand and maintain the code. 
With Jasmine, developers can define test suites and test cases, and then use various matchers to check 
the expected behavior of their code.

== Karma
Karma, on the other hand, is a test runner that allows developers to execute their tests in multiple 
browsers and environments. It provides a seamless integration with Jasmine, allowing developers to 
easily run their Jasmine tests in different browsers and get real-time feedback on the test results. Karma 
also offers additional features, such as code coverage reporting and continuous integration support.
Using Jasmine and Karma together can greatly enhance the testing process for Angular applications. 
Developers can write comprehensive test suites using Jasmine’s expressive syntax, and then use Karma 
to run these tests in various browsers, ensuring compatibility across different environments. This 
helps catch any potential issues or bugs early on and promotes a more robust and reliable application.

== Writing your first unit tests in an Angular project
Create a new component called CalculatorComponent by running the following command:

 ng g c calculator

After creating the component with the preceding command line, a calculator.component.
spec.ts file will be created in the src/ app/calculator folder. When you open the 
file, you’ll see the following code by default:
[source,javascript,attributes]
----
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { Calculator } from './calculator';

describe('Calculator', () => {
  let component: Calculator;
  let fixture: ComponentFixture<Calculator>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [Calculator]
    })
    .compileComponents();

    fixture = TestBed.createComponent(Calculator);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
----
In the preceding generated code, we have a test suite where we have used the describe
function, providing a descriptive name for the component under test. Within the test 
suite, we have a beforeEach block to set up the test environment. The TestBed.
configureTestingModule method is used to configure the test module and provide 
the necessary dependencies. The calculator variable is then assigned to an instance of 
CalculatorComponent using the TestBed.inject method.

CalculatorComponent component will enable us to perform basic arithmetic 
operations. To write a unit test using TDD, we’ll start by creating a test case that verifies the 
component’s expected behavior.

Now, we’ll write the actual test case using the it function. In this case, we’ll test the add
method of CalculatorComponent by passing it two numbers and expecting the result to 
be 5. The expect function is used to define the expected behavior and check the actual result. 
The following code must be added to the test suite – that is, inside the describe function:
[source,javascript,attributes]
----
  it('should add two numbers correctly', () => {
    const result = component.add(2, 3);
    expect(result).toBe(5)
  });
----
This is normal as it hasn’t been created yet.
Upon returning to our Karma server, we’ll see that our test case isn’t displayed in 
CalculatorComponent and that in the terminal, we have an error related to the non-existence 
of the function and a message indicating that no test has succeeded.

Next, we will implement the add function in calculator.component.ts. Having 
defined our first test case, we can proceed to implement calculator.component.ts for 
the test to pass. Following the TDD approach, write the minimum amount of code necessary 
to pass the tests:
[source,javascript,attributes]
----
  add(a: number, b: number) {
    return a + b;
  }
----
Once the tests have passed, you can refactor the code to improve its design, readability, and maintainability. 
Refactoring is an essential step in the TDD process as it helps eliminate duplication and improves 
code structure and overall quality. It is essential to ensure that tests continue to run after refactoring. 
Regularly reviewing and updating tests as the code base evolves will help maintain the integrity and 
reliability of unit tests.

== Code coverage and test result analysis with Karma
Code coverage and test result analysis are essential aspects of the software development process. By 
measuring code coverage, developers can assess the effectiveness of their unit tests and identify areas 
that require additional testing. Karma, a popular testing framework in the JavaScript ecosystem, 
provides built-in support for code coverage and test result analysis. 

Code coverage and test result analysis are essential aspects of the software development process. By 
measuring code coverage, developers can assess the effectiveness of their unit tests and identify areas 
that require additional testing. Karma, a popular testing framework in the JavaScript ecosystem, 
provides built-in support for code coverage and test result analysis. In this section, we’ll learn how 
to leverage Karma to measure code coverage, generate detailed reports, and analyze test results. By 
utilizing these features, developers can ensure comprehensive testing and improve the overall quality 
and reliability of their code.

Here are the different steps Angular performs for us:

1. Step 1 – setting up Karma with code coverage:
To utilize code coverage with Karma, start by installing the necessary dependencies:
  npm install --save-dev karma-coverage
2. Step 2 – Next, configure Karma to generate code coverage reports. Update your Karma configuration 
file (karma.conf.js) with the following changes:
[source,json,attributes]
----
    coverageReporter: {
      dir: require('path').join(__dirname, './coverage/getting-started-angular-tdd'),
      subdir: '.',
      reporters: [
        { type: 'html' },
        { type: 'text-summary' }
      ]
    },
    reporters: ['progress', 'kjhtml'],
----
This configuration specifies the reporters to be used (progress for test progress and coverage
for code coverage). The coverageReporter section defines the output directory and the 
types of reports to generate (HTML and Text Summary).
3. Step 3 – running tests and generating code coverage reports:
+
After configuring Karma for code coverage, run your tests as usual. Karma will now generate 
code coverage reports alongside the test results. These coverage reports provide insights into 
which parts of your code base are covered by tests and which areas require additional testing.
+
Once the tests have finished running, navigate to the coverage directory to view the generated 
reports. Open the HTML report (coverage/report-html/index.html) in a web 
browser to visualize the code coverage details. The report highlights covered lines, uncovered 
lines, and overall coverage percentages. 
4. Step 4 – analyzing the test results:
+
Karma also offers features to analyze the test results, including test reporting and integration 
with popular continuous integration (CI) tools. By leveraging these capabilities, developers can 
gain insights into test failures, identify patterns, and track the overall health of their test suite.
Karma provides various reporters that offer different levels of detail in the test output. For 
example, mocha-reporter displays detailed information about test failures, including stack 
traces and error messages, whereas junit-reporter generates JUnit-style XML reports 
that can be consumed by CI tools for further analysis.
To integrate Karma with CI tools, configure the respective plugin or reporter in your Karma 
configuration file. For example, to generate JUnit reports for Jenkins, add the karma-junit-
reporter plugin and configure it accordingly.
5. Step 5 – utilizing thresholds and quality gates:
Karma allows developers to define thresholds and quality gates for code coverage and test 
results. By setting these thresholds, developers can establish the minimum requirements for 
code coverage and test success rates. This ensures that the code base maintains a certain level 
of quality and reduces the risk of shipping untested or poorly covered code.
+
To set thresholds for code coverage, update your Karma configuration file as follows:
[source,javascript,attributes]
----
module.exports = function(config) {
 config.set({
 // ...
 coverageReporter: {
 // ...
 check: {
 global: {
 statements: 80,
 branches: 80,
 functions: 80,
 lines: 80
 }
 }
 },
 // ...
 });
};
----

In this example, the thresholds have been set to 80% for statements, branches, functions, and
lines. If any of these thresholds are not met, Karma will report a failed test result.

=== Code coverage visualization
Let’s run the following command in our project’s terminal:
  ng test –code-coverage

== Testing Components
=== Testing lifecycle hooks
Angular provides several lifecycle hooks that allow us to perform actions at specific stages of a component’s lifecycle. Testing these hooks ensures that our components behave as expected:

• ngOnInit(): The ngOnInit() hook is called after the component has been initialized. we can use this hook to set the initial values and perform any 
necessary setup.To test ngOnInit(), we can verify whether the initial values are correctly 
set and whether any necessary setup is performed.
• ngOnChanges(): The ngOnChanges() hook is called whenever there are changes to 
the component’s input properties. we can use this hook to 
update the component state based on the changes. To test ngOnChanges(), we can simulate 
changes to the input properties and verify whether the component state is updated accordingly.
• ngOnDestroy(): The ngOnDestroy() hook is called just before the component is 
destroyed. we can use this hook to clean up any resources 
or subscriptions. To test ngOnDestroy(), we can simulate the component destruction and 
verify whether the necessary cleanup actions are performed.
[tabs]
====
calculator.component.ts::
+
[source, javascript]
----
export class Calculator {
  result!: number;

  ngOnInit(): void {
    this.result = 0;
  }
}
----

calculator.component.spec.ts::
+
[source, javascript]
----
it('should initialize result to 0', () => {
    calculator.ngOnInit();
    expect(calculator.result).toEqual(0);
  });
----
====

== Testing Services
=== Testing testing methods

[tabs]
====
calculator.service.ts::
+
[source, javascript]
----
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class CalculatorService {
  private resultSubject = new BehaviorSubject<number>(0);
  public result$ = this.resultSubject.asObservable();

  constructor() { }

  add(a: number, b: number): number {
    return a + b;
  }

  substract(a: number, b: number): number {
    return a - b;
  }

  multiply(a: number, b: number): number {
    return a * b;
  }

  divide(a: number, b: number): number {
    return a / b;
  }
}
----

calculator.service.spec.ts::
+
[source, javascript]
----
import { TestBed } from '@angular/core/testing';

import { CalculatorService } from './calculator.service';
import { provideZonelessChangeDetection } from '@angular/core';

describe('Calculator', () => {
  let service: CalculatorService;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [],
      providers: [provideZonelessChangeDetection()
      ]
    })
    service = TestBed.inject(CalculatorService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
----

calculator.component.ts::
+
[source, javascript]
----
 add(a: number, b: number): void {
    this.result = this.calculatorService.add(a, b);
  }
----

calculator.component.spec.ts::
+
[source, javascript]
----
  it('should add two numbers correctly', () => {
    spyOn(calculatorService, 'add').and.callThrough();
    calculator.add(2, 3);
    expect(calculatorService.add).toHaveBeenCalledWith(2, 3);
    expect(calculator.result).toBe(5);
  });
----
====

=== Testing HTTP requests
=== Testing observables
=== Testing error handling

== Testing directives

In our current calculator application development project, we’re going to use a directive to apply a 
color to the calculation result displayed on the screen.

To handle color changes in our Angular calculator application, we’re going to create a custom directive. 
Directives allow us to extend the functionality of HTML elements and encapsulate specific behaviors.
In this case, we’ll create a directive called colorChange that will be responsible for handling color 
transitions. The directive will accept an input parameter specifying the color to be changed. It will 
then apply the CSS styles required to achieve the desired effect.

When we want to use a directive on an HTML tag that takes a property as a parameter, here’s what it looks like:
  <p [colorChange]="color"> </p>
According to the preceding code, colorChange is our directive. It takes color as a parameter. This 
implies that color is an attribute of our component. 
[tabs]
====
calculator.component.ts::
+
[source, javascript]
----
export class CalculatorComponent {
  color = 'red';
}
----

calculator.component.html::
+
[source, html]
----
<p [colorChange]="color"> {{ result }} </p>
----

color-change.directive.ts::
+
[source, javascript]
----
import { Directive, ElementRef, Input, OnInit, Renderer2 } from '@angular/core';

@Directive({
  selector: '[colorChange]',
  standalone: true
})
export class ColorChangeDirective implements OnInit {
  @Input() colorChange!: string;
  
  constructor(private elementRef: ElementRef, private renderer: Renderer2) { }

  ngOnInit() {
    this.renderer.setStyle(this.elementRef.nativeElement, 'color', this.colorChange);
  }
}

----

color-change.directive.spec.ts::
+
[source, javascript]
----
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { CalculatorComponent } from '../../calculator/calculator.component';
import { By } from '@angular/platform-browser';
import { provideZonelessChangeDetection } from '@angular/core';

describe('ColorChangeDirective', () => {
  let fixture: ComponentFixture<CalculatorComponent>;
  let calculator: CalculatorComponent;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      providers: [provideZonelessChangeDetection()
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(CalculatorComponent);
    calculator = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should apply the specified color', () => {
    const element: HTMLElement = fixture.debugElement.query(By.css('p')).nativeElement;
    const color: string = 'red';
    calculator.color = color;
    fixture.detectChanges();

    expect(element.style.color).toBe(color);
  });
});
----
====

== Monitoring and controlling dependency calls using method stubs and spies
One crucial aspect of testing in Angular applications is the ability to monitor and control dependency 
calls. Dependencies are external resources or services that a piece of code relies on to function correctly. 
Monitoring and controlling these dependency calls allows developers to ensure that their code interacts 
correctly with external systems and handles different scenarios gracefully.

Spies and method stubs are two powerful techniques within Angular’s testing framework that enable 
developers to achieve this level of control. Spies allow developers to monitor function calls, record 
information about those calls, and assert expectations about their usage. On the other hand, method 
stubs provide a way to replace real dependencies with simplified versions, allowing developers to 
control the behavior of those dependencies during testing.

By using spies, developers can verify that the correct functions are called with the right parameters 
and that they are called the expected number of times. This is particularly useful when testing code 
that interacts with external APIs or databases. 

Method stubs, on the other hand, enable developers 
to simulate different scenarios and provide predefined responses to method calls. This allows for 
thorough testing of edge cases and ensures the code’s robustness.

=== Method stubs and spies
Method stubs, also known as fake or dummy objects, are used to replace real dependencies with 
simplified versions during testing. By providing predefined responses to method calls, method 
substitutes enable developers to isolate and control the behavior of the code under test

==== Method stubs

[tabs]
====
In the calculator application, let’s consider a scenario in which the user performs a division operation 
with a divisor equal to zero. We want to make sure that the application handles this scenario correctly. 
By creating a method plug for the divide function, we can simulate the divide-by-zero scenario and 
check that the application displays an appropriate error message.
+
[source,javascript,attributes]
----
  it('should raise an exception when dividing by zero', () => {
    spyOn(calculatorService, 'divide').and.callThrough();

    expect(() => calculator.divide(10, 0))
      .toThrowError('Cannot divide by zero');

    expect(calculatorService.divide).toHaveBeenCalledWith(10, 0);
  });
----
+
At present, our calculator’s division operation does not handle the exception related to division by zero.
In our calculator.component.spec.ts test file, we’re going to add the test that allows us to 
raise this exception. Since we’re following TDD principles, the test should fail naturally
+
To correct this, we need to update our CalculatorService. In our present scenario, there’s a 
clever approach to refrain from direct interaction with our core service and ensure that everything is 
operational prior to any such action. This approach involves the utilization of a method stub concept.
+
Basically, we’ll point our CalculatorService service at a fake service that will enable us to 
check the correctness of the logic we want to implement before modifying the service itself. In 
fact, this fake service will simply be a stub method that replaces the classic division of our basic 
CalculatorService service. 
+
we’ll declare this stub method:
+
[source,javascript,attributes]
----
const calculatorServiceStub = {
  divide: (a: number, b: number) => {
    if (b === 0) {
      throw new Error('Cannot divide by zero');
    }
    return a / b;
  },
};
----
+
Then, in the describe method, within the configureTestingModule method, we will replace 
our CalculatorService provider with the following:
[source,javascript,attributes]
----
  providers: [provideZonelessChangeDetection(),
  {
    provide: CalculatorService, useValue: calculatorServiceStub
  }
----

CalculatorServiceStub::
+
[source, javascript]
----
export class CalculatorServiceStub {
    add(a: number, b: number): number {
        return a + b;
    }

    substract(a: number, b: number): number {
        return a - b;
    }

    multiply(a: number, b: number): number {
        return a * b;
    }

    divide(a: number, b: number): number | Error {
        if (b === 0) {
            throw new Error('Cannot divide by zero');
        }
        return a / b;
    }
}
----

calculator.component.spec.ts::
+
[source, javascript]
----
describe('CalculatorComponentUsingCalculatorServiceStubService', () => {
  let calculator: CalculatorComponent;
  let fixture: ComponentFixture<CalculatorComponent>;
  let calculatorService: CalculatorService;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [CalculatorComponent, ColorChangeDirective],
      providers: [provideZonelessChangeDetection(),
      {
        provide: CalculatorService, useClass: CalculatorServiceStub
      }
      ]
    })
      .compileComponents();

    fixture = TestBed.createComponent(CalculatorComponent);
    calculator = fixture.componentInstance;
    calculatorService = TestBed.inject(CalculatorService);
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(calculator).toBeTruthy();
  });

  it('should initialize result to 0', () => {
    calculator.ngOnInit();
    expect(calculator.result).toEqual(0);
  });

  it('should add two numbers correctly', () => {
    spyOn(calculatorService, 'add').and.callThrough();
    calculator.add(2, 3);
    expect(calculatorService.add).toHaveBeenCalledWith(2, 3);
    expect(calculator.result).toBe(5);
  });

  it('should substract two numbers correctly', () => {
    spyOn(calculatorService, 'substract').and.callThrough();
    calculator.substract(2, 3);
    expect(calculatorService.substract).toHaveBeenCalledWith(2, 3);
    expect(calculator.result).toBe(-1);
  });

  it('should multiply two numbers correctly', () => {
    spyOn(calculatorService, 'multiply').and.callThrough();
    calculator.multiply(2, 3);
    expect(calculatorService.multiply).toHaveBeenCalledWith(2, 3);
    expect(calculator.result).toBe(6);
  });

  it('should divide two numbers correctly', () => {
    spyOn(calculatorService, 'divide').and.callThrough();
    calculator.divide(4, 2);
    expect(calculatorService.divide).toHaveBeenCalledWith(4, 2);
    expect(calculator.result).toBe(2);
  });

  it('should raise an exception when dividing by zero', () => {
    spyOn(calculatorService, 'divide').and.callThrough();

    expect(() => calculator.divide(10, 0))
      .toThrowError('Cannot divide by zero');

    expect(calculatorService.divide).toHaveBeenCalledWith(10, 0);
  });
});
----
====

== Injecting mocked dependencies using TestBed providers
Mocked dependencies are simplified versions of external services or resources that mimic the behavior 
of the actual dependencies. By injecting these mocked dependencies using TestBed providers, 
developers can control their behavior during testing, ensuring reliable and thorough testing without 
relying on external systems.

TestBed providers enable developers to inject mocked dependencies 
into their code. By doing so, we can create isolated and controlled testing environments, adhering to 
the principles of TDD.

By injecting mocked dependencies using TestBed providers, developers can focus on testing specific 
units of code without worrying about the complexities of the actual dependencies. This approach 
allows for easier debugging, improved test coverage, and better overall code quality.

When configuring the testing module using TestBed.configureTestingModule, you can 
provide a list of providers that specify the tokens for the dependencies you want to mock. You can 
then use either the useClass or useValue property to provide a mock or stub implementation 
for each dependency.


[tabs]
======

Calaculator Example::
+
Let’s consider adding the ability to calculate the square root of a number to our calculator application, 
while still relying on our CalculatorService service. In this case, we’ll focus on the square root 
functionality of the calculator application.
+
Here’s an example of a mock square root service:
[source,javascript,attributes]
----
export class MockSquareRootService {
    calculateSquareRoot(value: number): number {
        // Perform a predefined square root calculation based on the input 
        value
        return Math.sqrt(value);
    }
}
----
+
Next, we will configure the test module using TestBed providers to replace the real square root service 
with the simulated version in calculator.component.spec.ts. Here’s an example of how 
to configure the test module:
[source,javascript,attributes]
----
import { MockSquareRootService } from './mock-square-root.service';
...
beforeEach(async () => {
 await TestBed.configureTestingModule({
 ...
 providers: [{ provide: CalculatorService, useClass: 
MockSquareRootService }]
 }).compileComponents();
----
+
This configuration tells TestBed to use the mock service whenever the code under test requests an instance of the actual square root service.
+
Now, when we run our tests for the calculator app, any code that depends on the square root service will 
receive an instance of the mocked service. We can control the behavior of the service during testing, 
ensuring that the calculator app correctly performs square root calculations under different scenarios. 
Here’s some example code for the MockSquareRootService service that mimics the behavior of 
the CalculatorService service by returning predefined square root values for different inputs:

[tabs]
====
src/app/core/mocks/mock-square-root.service.mock.ts::
+
[source, javascript]
----
export class MockSquareRootService {
    squareRoot(value: number): number {
        // Perform a predefined square root calculation based on the input value
        if (value === 4) {
            return 2;
        } else if (value === 9) {
            return 3;
        } else if (value === 16) {
            return 4;
        } else {
            throw new Error('Invalid input');
        }
    }
}
----

src/app/calculator/calculator.component.spec.ts::
+
[source, javascript]
----
describe('CalculatorComponentUsingMockSquareRootService', () => {
  let calculator: CalculatorComponent;
  let fixture: ComponentFixture<CalculatorComponent>;
  let calculatorService: CalculatorService;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [CalculatorComponent, ColorChangeDirective],
      providers: [provideZonelessChangeDetection(),
      {
        provide: CalculatorService, useClass: MockSquareRootService
      }
      ]
    })
      .compileComponents();

    fixture = TestBed.createComponent(CalculatorComponent);
    calculator = fixture.componentInstance;
    calculatorService = TestBed.inject(CalculatorService);
    fixture.detectChanges();
  });

  it('should calculate the square root correctly', () => {
    spyOn(calculatorService, 'squareRoot').and.callThrough();
    calculator.squareRoot(16);
    expect(calculatorService.squareRoot).toHaveBeenCalledWith(16);
    expect(calculator.result).toBe(4);
  });
});
----
====

Another Example::
+
[source, java]
----
----

======

== Handling async operations
`fakeAsync` This is an Angular utility function that lets you write tests that rely on asynchronous 
operations synchronously. It is useful for testing code that uses observables, promises, or other 
asynchronous operations.

[tabs]
======

Calaculator Example::
+
Let’s consider that our calculator application that performs addition, subtraction, multiplication, and 
division now has a service that performs these operations and returns the result as an observable.
+
First, let’s assume we have another calculator service called CalculatorAsyncService
+
[tabs]
====
src/app/core/services/calculater-async.ts::
+
[source, javascript]
----
import { Injectable } from '@angular/core';
import { Observable, catchError, of, throwError } from 'rxjs';

@Injectable({
  providedIn: 'root',
})
export class CalculatorAsyncService {
  constructor() { }

  add(a: number, b: number): Observable<number> {
    return of(a + b);
  }

  subtract(a: number, b: number): Observable<number> {
    return of(a - b);
  }

  multiply(a: number, b: number): Observable<number> {
    return of(a * b);
  }

  divide(a: number, b: number): Observable<number> {
    if (b === 0) {
      return throwError(() => new Error('Cannot divide by zero'));
    }
    /*
    the catchError operator is used to 
    catch any errors that may occur during the divide operation and throw them back using 
    the throwError function. This ensures that if an error occurs (other than division by zero, 
    which is explicitly handled), the observable will issue an error notification.
    */
    return of(a / b).pipe(
      catchError((error) => {
        return throwError(() => error);
      })
    );
  }
}
----

src/app/core/services/calculater-async.spec.ts::
+
[source, javascript]
----
import { TestBed } from '@angular/core/testing';

import { provideZonelessChangeDetection } from '@angular/core';
import { CalculatorAsyncService } from './calculater-async';

describe('CalculatorAsyncService', () => {
  let service: CalculatorAsyncService;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [],
      providers: [provideZonelessChangeDetection()
      ]
    })
      .compileComponents();
    service = TestBed.inject(CalculatorAsyncService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });

  it('should add two numbers', async () => {
    let result = 0;
    service.add(1, 2).subscribe((val: number) => {
      result = val;
    });
    expect(result).toBe(3);
  });

  it('should subtract two numbers', async () => {
    let result = 0;
    service.subtract(5, 3).subscribe((val: number) => {
      result = val;
    });

    expect(result).toBe(2);
  });

  it('should multiply two numbers', async () => {
    let result = 0;
    service.multiply(3, 4).subscribe((val: number) => {
      result = val;
    });

    expect(result).toBe(12);
  });

  it('should divide two numbers', async () => {
    let result = 0;
    service.divide(10, 2).subscribe((val: number) => {
      result = val;
    });

    expect(result).toBe(5);
  });

  it('should throw an error when dividing by zero', async () => {
    let error = { message: '' };
    service.divide(10, 0).subscribe({
      error: (err) => (error = err),
    });
    expect(error).toBeTruthy();
    expect(error.message).toBe('Cannot divide by zero');
  });
});
----
====

Another Example::
+
[source, java]
----
----

======