= Spring Reactive programming
:figures: 11-development/02-spring/03-web

When you build applications with Spring, you can choose between a servlet stack and a
reactive stack. The servlet stack relies on synchronous, blocking I/O and uses the thread-
per-request model to handle requests. On the other hand, the reactive stack relies on
asynchronous, non-blocking I/O and uses the event loop model to handle requests.

The servlet stack is based on the Servlet API and a Servlet container (such as Tom-
cat). In contrast, the reactive model is based on the Reactive Streams API (implemented
by Project Reactor) and either Netty or a Servlet container (version 3.1 as a minimum).
Both stacks let you build RESTful applications using either classes annotated as @Rest-
Controller or functional endpoints called router functions. The servlet stack uses Spring MVC, while the reactive stack uses Spring WebFlux. 

Tomcat is the default choice for servlet-based applications. Netty is the preferred choice for reactive applications, providing the best performance.

image::{figures}/servlet-stack-vs-reactive-stack.png[The servlet stack is based on the Servlet API and supports synchronous and blocking operations. The reactive stack is based on Project Reactor and supports asynchronous and non-blocking operations]

Reactive Spring is based on Project Reactor, a framework for building asynchronous,
non-blocking applications on the JVM. Reactor is an implementation of the Reactive
Streams specification, and it aims to provide “a standard for asynchronous stream pro-
cessing with non-blocking back pressure” (www.reactive-streams.org).

Conceptually, reactive streams resemble the Java Stream API in the way we use them
to build data pipelines. One of the key differences is that a Java stream is pull-based: consumers process data in an imperative and synchronous fashion. Instead, reactive
streams are push-based: consumers are notified by the producers when new data is
available, so the processing happens asynchronously.

Reactive streams work according to a producer/consumer paradigm. Producers
are called publishers. They produce data that might be eventually available. Reactor
provides two central APIs implementing the Producer<T> interface for objects of type
<T>, and they are used to compose asynchronous, observable data streams: Mono<T>
and Flux<T>:

* Mono<T>—Represents a single asynchronous value or empty result (0..1)
* Flux<T>—Represents an asynchronous sequence of zero or more items (0..N)

In a Java stream, you would process objects like Optional<Customer> or Collection
<Customer>. In a reactive stream, you would have Mono<Customer> or Flux<Customer>.
The possible outcomes of a reactive stream are an empty result, a value, or an error.
All of them are handled as data. When the publisher returns all the data, we say that
the reactive stream has been completed successfully.

Consumers are called subscribers because they subscribe to a publisher and are noti-
fied whenever new data is available. As part of the subscription, consumers can also
define backpressure by informing the publisher that they can process only a certain
amount of data at a time. That is a powerful feature that puts consumers in control of
how much data is received, preventing them from being overwhelmed and becoming
unresponsive. Reactive streams are only activated if there’s a subscriber.

You can build reactive streams that combine data from different sources and
manipulate it using Reactor’s vast collection of operators. In a Java stream, you can use
a fluent API to process data through operators like map, flatMap, or filter, each of
which builds a new Stream object that keeps the previous step immutable. Similarly,
you can build reactive streams using a fluent API and operators to process the data
received asynchronously.

Besides the standard operators available to Java streams, you can use more power-
ful ones to apply backpressure, handle errors, and increase application resilience. For
example, the retryWhen() and timeout() operators. Operators can
perform actions on a publisher and return a new publisher without modifying the
original one, so you can build functional and immutable data streams with ease.

Project Reactor is the foundation of the Spring reactive stack, which lets you imple-
ment your business logic in terms of Mono<T> and Flux<T>.

The programming model is based on processing streams of data, and the core data types in Project 
Reactor are Flux and Mono. A Flux object is used to process a stream of 0...n elements and a Mono
object is used to process a stream that either is empty or returns at most one element. 
[source,java,attributes]
----
@Test
void testFlux() {
 List<Integer> list = Flux.just(1, 2, 3, 4)
 .filter(n -> n % 2 == 0)
 .map(n -> n * 2)
 .log()
 .collectList().block();
 assertThat(list).containsExactly(4, 8);
}
----

Here is an explanation of the preceding source code:

1. We initiate the stream with the integers 1, 2, 3, and 4 using the static helper method Flux.just().
2. Next, we filter out the odd numbers – we only allow even numbers to proceed through the 
stream. In this test, these are 2 and 4.
3. Next, we transform (or map) the values in the stream by multiplying them by 2, so they become 
4 and 8.
4. Then, we log the data that flows through the stream after the map operation.
5. We use the collectList method to collect all items from the stream into a List, emitted once 
the stream completes.
6. So far, we have only declared the processing of a stream. To actually get the stream processed, 
we need someone to subscribe to it. The final call to the block method will register a subscriber 
that waits for the processing to complete.
7. The resulting list is saved in a member variable named list.
8. We can now wrap up the test by using the assertThat method to assert that list after the 
processing of the stream contains the expected result – the integers 4 and 8.

== Configuring Emedded Server(Netty)
The default and recommended embedded server for reactive applications in Spring
Boot is Reactor Netty, which is built on top of Netty to provide reactive capabilities
within Project Reactor. You can configure it either through properties or by defining a WebServerFactoryCustomizer<NettyReactiveWebServerFactory> component. 

[source,yml,attributes]
----
server:
  port: 9002
  # By default, Spring Boot stops the server immediately after receiving a terminationsignal (SIGTERM). 
  # You can switch to a graceful mode by configuring the server.shut-down property. 
  shutdown: graceful
  netty:
    # How long to wait for a TCP connection to be established with the server
    connection-timeout: 2s
    # How long to wait before closing a TCP connection if no data is transferred
    idle-timeout: 15s 

spring:
  application:
    name: order-service
  lifecycle:
    #    You can also configure the grace period, which is how long the applica-
    # tion can spend processing all the pending requests. After the grace period expires,
    # the application is terminated even if there are still pending requests. By default, the
    # grace period is 30 seconds. 
    timeout-per-shutdown-phase: 15s 
----

== Exposing a REST API with Spring WebFlux
There are two options for defining RESTful endpoints in a Spring WebFlux application: @RestController classes or functional beans (router functions).
=== Using @RestController classes
[source,java,attributes]
----
@RestController
@RequestMapping("orders")
public class OrderController {

    private final OrderService orderService;

    public OrderController(OrderService orderService) {
        this.orderService = orderService;
    }

    @GetMapping
    public Flux<Order> getAllOrders() {
        return orderService.getAllOrders();
    }

    @PostMapping
    public Mono<Order> submitOrder(@RequestBody @Valid OrderRequest orderRequest) {
        return orderService.submitOrder(orderRequest.isbn(), orderRequest.quantity());
    }

}
----

=== Using functional beans (router functions)

== Reactive clients with Spring WebClient
WebClient is the modern alternative to RestTemplate. It provides blocking and
non-blocking I/O, making it the perfect candidate for both imperative and reactive
applications. It can be operated through a functional-style, fluent API that lets you
configure any aspect of the HTTP interaction.

== Resilient applications with Reactive Spring
A popular library for implementing such patterns was Hystrix, developed by Net-
flix, but as of 2018 it entered maintenance mode and will not be developed further.
Resilience4J gained a lot of popularity, filling the void left by Hystrix. Project Reactor,
the Reactive Spring stack foundation, also provides some useful features for resilience.

You can use the Reactor operators to configure timeouts, retries, fallbacks, and
error handling to make the interaction more resilient to any failure in the ser-
vice downstream or due to the network
== Using Reactive Spring
=== Non-blocking persistence using Spring Data for MongoDB
Making the MongoDB-based repositories reactive is very simple:

• Change the base class for the repositories to ReactiveCrudRepository
• Change the custom finder methods to return either a Mono or a Flux object
[source,java,attributes]
----
public interface ProductRepository extends ReactiveCrudRepository<ProductEntity, String> {
    Mono<ProductEntity> findByProductId(int productId);
}
----

=== DEFINING Timeouts FOR WEBCLIENT
Project Reactor provides a timeout() operator you can use to define a time limit for
completing an operation. You can chain it with the result of the WebClient call to continue the reactive stream. 
[source,java,attributes]
----
public Mono<Book> getBookByIsbn(String isbn) {
    return webClient
            .get()
            .uri(BOOKS_ROOT_API + isbn)
            .retrieve()
            .bodyToMono(Book.class)
            // The fallback returns an empty Mono object.
            .timeout(Duration.ofSeconds(3), Mono.empty())
            .onErrorResume(WebClientResponseException.NotFound.class, exception -> Mono.empty())
}
----
=== DEFINING RETRIES FOR WEBCLIENT
Project Reactor provides a retryWhen() operator to retry an operation when it fails.
The position where you apply it to the reactive stream matters.

* Placing the retryWhen() operator after timeout() means that the timeout is
applied to each retry attempt.
* Placing the retryWhen() operator before timeout() means that the timeout is
applied to the overall operation (that is, the whole sequence of the initial
request and retries has to happen within the given time limit).

You can define the number of attempts and the minimum duration for the
first backoff. The delay is computed for each retry as the current attempt number
multiplied by the minimum backoff period. A jitter factor can be used to add random-
ness to the exponential of each backoff. By default, a jitter of at most 50% of the com-
puted delay is used. When you have multiple instances of Order Service running, the
jitter factor ensures that the replicas will not retry requests simultaneously.

[source,java,attributes]
----
public Mono<Book> getBookByIsbn(String isbn) {
    return webClient
            .get()
            .uri(BOOKS_ROOT_API + isbn)
            .retrieve()
            .bodyToMono(Book.class)
            /*
                * Instead of throwing an exception when the timeout expires, you have the
                * chance to pro-
                * vide a fallback behavior. Considering that Order Service can’t accept an
                * order if the
                * book’s availability is not verified, you might consider returning an empty
                * result so that
                * the order will be rejected. You can define a reactive empty result using
                * Mono.empty().
                */
            /*
                * In a real production scenario, you might want to externalize the time out
                * configuration by adding a new field to the ClientProperties.
                * In that way, you can change its value depending on the environment without
                * having to rebuild the application. It’s also essential to monitor any timeout
                * and tune its value if necessary.
                */
            .timeout(Duration.ofSeconds(3), Mono.empty())
            .onErrorResume(WebClientResponseException.NotFound.class, exception -> Mono.empty())
            /*
                * we want the timeout to apply to each retry attempt, so we’ll use
                * the retryWhen() operator after timeout() whic means that the timeout is
                * applied to each retry attempt. The time limiter is applied first. If the
                * timeout expires, the retryWhen()
                * operator kicks in and tries the request again.
                */
                /*
                 * Exponential backoff is used
                 * as the retry strategy. Three
                 * attempts are allowed with
                 * a 100 ms initial backoff
                 */
            .retryWhen(Retry.backoff(3, Duration.ofMillis(100)))
            .onErrorResume(Exception.class, exception -> Mono.empty());
}
----
=== Fallbacks and error handling
Some errors are acceptable and semantically meaningful in the context of your
business logic. When Order Service calls Catalog Service to fetch information about a
specific book, a 404 response might be returned. That’s an acceptable response that
should be addressed to inform the user that the order cannot be submitted because
the book is not available in the catalog.

The retry strategy you defined in the previous section is not limited: it will retry the
request as long as an error response is received, including acceptable ones like 404.
However, in that case, you don’t want to retry the request. Project Reactor provides an
onErrorResume() operator to define a fallback when a specific error occurs. You can
add it to the reactive stream after the timeout() operator and before the retry-
When() so that if a 404 response is received (WebClientResponseException.NotFound
exception), the retry operator is not triggered. Then you can use the same operator
again at the end of the stream to catch any other exception and fall back to an empty
Mono. Update the getBookByIsbn() method in the BookClient class as follows.

[source,java,attributes]
----
public Mono<Book> getBookByIsbn(String isbn) {
    return webClient
            .get()
            .uri(BOOKS_ROOT_API + isbn)
            .retrieve()
            .bodyToMono(Book.class)
            .timeout(Duration.ofSeconds(3), Mono.empty())
            // Returns an empty object when a 404 response is received
            .onErrorResume(WebClientResponseException.NotFound.class, exception -> Mono.empty())
            .retryWhen(Retry.backoff(3, Duration.ofMillis(100)))
            // If any error happens after the 3 retry attempts, catch the exception and return an empty object.
            .onErrorResume(Exception.class, exception -> Mono.empty());
}
----
In a real-world scenario, you would probably want to return some con-
textual information depending on the type of error, instead of always return-
ing an empty object. For example, you could add a reason field to the Order
object to describe why it’s been rejected. Was it because the book is unavail-
able in the catalog or because of network problems? In the second case, you
could inform the user that the order cannot be processed because it’s
momentarily unable to check the book’s availability. A better option would be
to save the order in a pending state, queue the order submission request, and
try it again later, using strategies like  Event-driven architectures

== Using Resilience4J and Spring Cloud Circuit Breaker

== Examples

[tabs]
======
CaveatEmptor::
+
[tabs]
====
Country.java::
+
[source, java]
----
----
====

Cities API::
+
[tabs]
====
Country.java::
+
[source, java]
----
----
====

Multiplication microservices::
+
[source, java]
----
----

Microservices with Spring Boot 3 and Spring Cloud::
+
In this section, we will learn how to develop non-blocking versions of the read APIs. The composite 
service will make reactive, that is, non-blocking, calls in parallel to the three core services. When 
the composite service has received responses from all of the core services, it will create a composite 
response and send it back to the caller. This is illustrated in the following diagram:
+
images::{figures}/Microservices-with-Spring-Boot-and-Spring-Cloud-reactive-rest-api.png
+
ProductRepository and RecommendationRepository look like the following after the change:
public interface ProductRepository extends ReactiveCrudRepository
<ProductEntity, String> {
 Mono<ProductEntity> findByProductId(int productId);
}
public interface RecommendationRepository extends
ReactiveCrudRepository<RecommendationEntity, String> {
 Flux<RecommendationEntity> findByProductId(int productId);
}
No changes are applied to the persistence code for the review service; it will remain blocking using 
the JPA repository.

[tabs]
====
ProductRepository.java::
+
[source, java]
----
package se.magnus.microservices.core.product.persistence;

import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Mono;

public interface ProductRepository extends ReactiveCrudRepository<ProductEntity, String> {
    Mono<ProductEntity> findByProductId(int productId);
}
----

RecommendationRepository.java::
+
[source, java]
----
package se.magnus.microservices.core.recommendation.persistence;

import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux;

public interface RecommendationRepository extends ReactiveCrudRepository<RecommendationEntity, String> {
  Flux<RecommendationEntity> findByProductId(int productId);
}
----

ProductCompositeIntegration.java::
+
[source, java]
----
package se.magnus.microservices.composite.product.services;

import static java.util.logging.Level.FINE;
import static reactor.core.publisher.Flux.empty;
import static se.magnus.api.event.Event.Type.CREATE;
import static se.magnus.api.event.Event.Type.DELETE;

import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.IOException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.actuate.health.Health;
import org.springframework.cloud.stream.function.StreamBridge;
import org.springframework.http.HttpStatus;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Scheduler;
import se.magnus.api.core.product.Product;
import se.magnus.api.core.product.ProductService;
import se.magnus.api.core.recommendation.Recommendation;
import se.magnus.api.core.recommendation.RecommendationService;
import se.magnus.api.core.review.Review;
import se.magnus.api.core.review.ReviewService;
import se.magnus.api.event.Event;
import se.magnus.api.exceptions.InvalidInputException;
import se.magnus.api.exceptions.NotFoundException;
import se.magnus.util.http.HttpErrorInfo;

@Component
public class ProductCompositeIntegration implements ProductService, RecommendationService, ReviewService {

  private static final Logger LOG = LoggerFactory.getLogger(ProductCompositeIntegration.class);

  private final WebClient webClient;
  private final ObjectMapper mapper;

  private final String productServiceUrl;
  private final String recommendationServiceUrl;
  private final String reviewServiceUrl;

  private final StreamBridge streamBridge;

  private final Scheduler publishEventScheduler;

  @Autowired
  public ProductCompositeIntegration(
    @Qualifier("publishEventScheduler") Scheduler publishEventScheduler,

    WebClient.Builder webClient,
    ObjectMapper mapper,
    StreamBridge streamBridge,

    @Value("${app.product-service.host}") String productServiceHost,
    @Value("${app.product-service.port}") int  productServicePort,

    @Value("${app.recommendation-service.host}") String recommendationServiceHost,
    @Value("${app.recommendation-service.port}") int  recommendationServicePort,

    @Value("${app.review-service.host}") String reviewServiceHost,
    @Value("${app.review-service.port}") int  reviewServicePort
  ) {

    this.publishEventScheduler = publishEventScheduler;
    this.webClient = webClient.build();
    this.mapper = mapper;
    this.streamBridge = streamBridge;

    productServiceUrl        = "http://" + productServiceHost + ":" + productServicePort;
    recommendationServiceUrl = "http://" + recommendationServiceHost + ":" + recommendationServicePort;
    reviewServiceUrl         = "http://" + reviewServiceHost + ":" + reviewServicePort;
  }

  @Override
  public Mono<Product> createProduct(Product body) {

    return Mono.fromCallable(() -> {
      sendMessage("products-out-0", new Event(CREATE, body.getProductId(), body));
      return body;
    }).subscribeOn(publishEventScheduler);
  }

  @Override
  public Mono<Product> getProduct(int productId) {
    String url = productServiceUrl + "/product/" + productId;
    LOG.debug("Will call the getProduct API on URL: {}", url);

    return webClient.get().uri(url).retrieve().bodyToMono(Product.class).log(LOG.getName(), FINE).onErrorMap(WebClientResponseException.class, ex -> handleException(ex));
  }

  @Override
  public Mono<Void> deleteProduct(int productId) {

    return Mono.fromRunnable(() -> sendMessage("products-out-0", new Event(DELETE, productId, null)))
      .subscribeOn(publishEventScheduler).then();
  }

  @Override
  public Mono<Recommendation> createRecommendation(Recommendation body) {

    return Mono.fromCallable(() -> {
      sendMessage("recommendations-out-0", new Event(CREATE, body.getProductId(), body));
      return body;
    }).subscribeOn(publishEventScheduler);
  }

  @Override
  public Flux<Recommendation> getRecommendations(int productId) {

    String url = recommendationServiceUrl + "/recommendation?productId=" + productId;

    LOG.debug("Will call the getRecommendations API on URL: {}", url);

    // Return an empty result if something goes wrong to make it possible for the composite service to return partial responses
    return webClient.get().uri(url).retrieve().bodyToFlux(Recommendation.class).log(LOG.getName(), FINE).onErrorResume(error -> empty());
  }

  @Override
  public Mono<Void> deleteRecommendations(int productId) {

    return Mono.fromRunnable(() -> sendMessage("recommendations-out-0", new Event(DELETE, productId, null)))
      .subscribeOn(publishEventScheduler).then();
  }

  @Override
  public Mono<Review> createReview(Review body) {

    return Mono.fromCallable(() -> {
      sendMessage("reviews-out-0", new Event(CREATE, body.getProductId(), body));
      return body;
    }).subscribeOn(publishEventScheduler);
  }

  @Override
  public Flux<Review> getReviews(int productId) {

    String url = reviewServiceUrl + "/review?productId=" + productId;

    LOG.debug("Will call the getReviews API on URL: {}", url);

    // Return an empty result if something goes wrong to make it possible for the composite service to return partial responses
    return webClient.get().uri(url).retrieve().bodyToFlux(Review.class).log(LOG.getName(), FINE).onErrorResume(error -> empty());
  }

  @Override
  public Mono<Void> deleteReviews(int productId) {

    return Mono.fromRunnable(() -> sendMessage("reviews-out-0", new Event(DELETE, productId, null)))
      .subscribeOn(publishEventScheduler).then();
  }

  public Mono<Health> getProductHealth() {
    return getHealth(productServiceUrl);
  }

  public Mono<Health> getRecommendationHealth() {
    return getHealth(recommendationServiceUrl);
  }

  public Mono<Health> getReviewHealth() {
    return getHealth(reviewServiceUrl);
  }

  private Mono<Health> getHealth(String url) {
    url += "/actuator/health";
    LOG.debug("Will call the Health API on URL: {}", url);
    return webClient.get().uri(url).retrieve().bodyToMono(String.class)
      .map(s -> new Health.Builder().up().build())
      .onErrorResume(ex -> Mono.just(new Health.Builder().down(ex).build()))
      .log(LOG.getName(), FINE);
  }

  private void sendMessage(String bindingName, Event event) {
    LOG.debug("Sending a {} message to {}", event.getEventType(), bindingName);
    Message message = MessageBuilder.withPayload(event)
      .setHeader("partitionKey", event.getKey())
      .build();
    streamBridge.send(bindingName, message);
  }

  private Throwable handleException(Throwable ex) {

    if (!(ex instanceof WebClientResponseException)) {
      LOG.warn("Got a unexpected error: {}, will rethrow it", ex.toString());
      return ex;
    }

    WebClientResponseException wcre = (WebClientResponseException)ex;

    switch (HttpStatus.resolve(wcre.getStatusCode().value())) {

      case NOT_FOUND:
        return new NotFoundException(getErrorMessage(wcre));

      case UNPROCESSABLE_ENTITY:
        return new InvalidInputException(getErrorMessage(wcre));

      default:
        LOG.warn("Got an unexpected HTTP error: {}, will rethrow it", wcre.getStatusCode());
        LOG.warn("Error body: {}", wcre.getResponseBodyAsString());
        return ex;
    }
  }

  private String getErrorMessage(WebClientResponseException ex) {
    try {
      return mapper.readValue(ex.getResponseBodyAsString(), HttpErrorInfo.class).getMessage();
    } catch (IOException ioex) {
      return ex.getMessage();
    }
  }
}
----
ProductCompositeServiceImpl.java(non synchronous)::
+
[source, java]
----
package se.magnus.microservices.composite.product.services;

import static java.util.logging.Level.FINE;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;
import se.magnus.api.composite.product.*;
import se.magnus.api.core.product.Product;
import se.magnus.api.core.recommendation.Recommendation;
import se.magnus.api.core.review.Review;
import se.magnus.util.http.ServiceUtil;

@RestController
public class ProductCompositeServiceImpl implements ProductCompositeService {

  private static final Logger LOG = LoggerFactory.getLogger(ProductCompositeServiceImpl.class);

  private final ServiceUtil serviceUtil;
  private final ProductCompositeIntegration integration;

  @Autowired
  public ProductCompositeServiceImpl(ServiceUtil serviceUtil, ProductCompositeIntegration integration) {
    this.serviceUtil = serviceUtil;
    this.integration = integration;
  }

  @Override
  public Mono<Void> createProduct(ProductAggregate body) {

    try {

      List<Mono> monoList = new ArrayList<>();

      LOG.info("Will create a new composite entity for product.id: {}", body.getProductId());

      Product product = new Product(body.getProductId(), body.getName(), body.getWeight(), null);
      monoList.add(integration.createProduct(product));

      if (body.getRecommendations() != null) {
        body.getRecommendations().forEach(r -> {
          Recommendation recommendation = new Recommendation(body.getProductId(), r.getRecommendationId(), r.getAuthor(), r.getRate(), r.getContent(), null);
          monoList.add(integration.createRecommendation(recommendation));
        });
      }

      if (body.getReviews() != null) {
        body.getReviews().forEach(r -> {
          Review review = new Review(body.getProductId(), r.getReviewId(), r.getAuthor(), r.getSubject(), r.getContent(), null);
          monoList.add(integration.createReview(review));
        });
      }

      LOG.debug("createCompositeProduct: composite entities created for productId: {}", body.getProductId());

      return Mono.zip(r -> "", monoList.toArray(new Mono[0]))
        .doOnError(ex -> LOG.warn("createCompositeProduct failed: {}", ex.toString()))
        .then();

    } catch (RuntimeException re) {
      LOG.warn("createCompositeProduct failed: {}", re.toString());
      throw re;
    }
  }

  @Override
  public Mono<ProductAggregate> getProduct(int productId) {

    LOG.info("Will get composite product info for product.id={}", productId);
    return Mono.zip(
      values -> createProductAggregate((Product) values[0], (List<Recommendation>) values[1], (List<Review>) values[2], serviceUtil.getServiceAddress()),
      integration.getProduct(productId),
      integration.getRecommendations(productId).collectList(),
      integration.getReviews(productId).collectList())
      .doOnError(ex -> LOG.warn("getCompositeProduct failed: {}", ex.toString()))
      .log(LOG.getName(), FINE);
  }

  @Override
  public Mono<Void> deleteProduct(int productId) {

    try {

      LOG.info("Will delete a product aggregate for product.id: {}", productId);

      return Mono.zip(
        r -> "",
        integration.deleteProduct(productId),
        integration.deleteRecommendations(productId),
        integration.deleteReviews(productId))
        .doOnError(ex -> LOG.warn("delete failed: {}", ex.toString()))
        .log(LOG.getName(), FINE).then();

    } catch (RuntimeException re) {
      LOG.warn("deleteCompositeProduct failed: {}", re.toString());
      throw re;
    }
  }

  private ProductAggregate createProductAggregate(Product product, List<Recommendation> recommendations, List<Review> reviews, String serviceAddress) {

    // 1. Setup product info
    int productId = product.getProductId();
    String name = product.getName();
    int weight = product.getWeight();

    // 2. Copy summary recommendation info, if available
    List<RecommendationSummary> recommendationSummaries = (recommendations == null) ? null :
       recommendations.stream()
        .map(r -> new RecommendationSummary(r.getRecommendationId(), r.getAuthor(), r.getRate(), r.getContent()))
        .collect(Collectors.toList());

    // 3. Copy summary review info, if available
    List<ReviewSummary> reviewSummaries = (reviews == null)  ? null :
      reviews.stream()
        .map(r -> new ReviewSummary(r.getReviewId(), r.getAuthor(), r.getSubject(), r.getContent()))
        .collect(Collectors.toList());

    // 4. Create info regarding the involved microservices addresses
    String productAddress = product.getServiceAddress();
    String reviewAddress = (reviews != null && reviews.size() > 0) ? reviews.get(0).getServiceAddress() : "";
    String recommendationAddress = (recommendations != null && recommendations.size() > 0) ? recommendations.get(0).getServiceAddress() : "";
    ServiceAddresses serviceAddresses = new ServiceAddresses(serviceAddress, productAddress, reviewAddress, recommendationAddress);

    return new ProductAggregate(productId, name, weight, recommendationSummaries, reviewSummaries, serviceAddresses);
  }
}
----
====
Polar Book Shop::
+
[source, java]
----
----
======