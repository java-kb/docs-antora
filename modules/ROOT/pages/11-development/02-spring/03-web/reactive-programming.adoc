= Spring Reactive programming
:figures: 11-development/02-spring/03-web

When you build applications with Spring, you can choose between a servlet stack and a
reactive stack. The servlet stack relies on synchronous, blocking I/O and uses the thread-
per-request model to handle requests. On the other hand, the reactive stack relies on
asynchronous, non-blocking I/O and uses the event loop model to handle requests.

The servlet stack is based on the Servlet API and a Servlet container (such as Tom-
cat). In contrast, the reactive model is based on the Reactive Streams API (implemented
by Project Reactor) and either Netty or a Servlet container (version 3.1 as a minimum).
Both stacks let you build RESTful applications using either classes annotated as @Rest-
Controller or functional endpoints called router functions. The servlet stack uses Spring MVC, while the reactive stack uses Spring WebFlux. 

Tomcat is the default choice for servlet-based applications. Netty is the preferred choice for reactive applications, providing the best performance.

image::{figures}/servlet-stack-vs-reactive-stack.png[The servlet stack is based on the Servlet API and supports synchronous and blocking operations. The reactive stack is based on Project Reactor and supports asynchronous and non-blocking operations]

Reactive Spring is based on Project Reactor, a framework for building asynchronous,
non-blocking applications on the JVM. Reactor is an implementation of the Reactive
Streams specification, and it aims to provide “a standard for asynchronous stream pro-
cessing with non-blocking back pressure” (www.reactive-streams.org).

Conceptually, reactive streams resemble the Java Stream API in the way we use them
to build data pipelines. One of the key differences is that a Java stream is pull-based: consumers process data in an imperative and synchronous fashion. Instead, reactive
streams are push-based: consumers are notified by the producers when new data is
available, so the processing happens asynchronously.

Reactive streams work according to a producer/consumer paradigm. Producers
are called publishers. They produce data that might be eventually available. Reactor
provides two central APIs implementing the Producer<T> interface for objects of type
<T>, and they are used to compose asynchronous, observable data streams: Mono<T>
and Flux<T>:

* Mono<T>—Represents a single asynchronous value or empty result (0..1)
* Flux<T>—Represents an asynchronous sequence of zero or more items (0..N)

In a Java stream, you would process objects like Optional<Customer> or Collection
<Customer>. In a reactive stream, you would have Mono<Customer> or Flux<Customer>.
The possible outcomes of a reactive stream are an empty result, a value, or an error.
All of them are handled as data. When the publisher returns all the data, we say that
the reactive stream has been completed successfully.

Consumers are called subscribers because they subscribe to a publisher and are noti-
fied whenever new data is available. As part of the subscription, consumers can also
define backpressure by informing the publisher that they can process only a certain
amount of data at a time. That is a powerful feature that puts consumers in control of
how much data is received, preventing them from being overwhelmed and becoming
unresponsive. Reactive streams are only activated if there’s a subscriber.

You can build reactive streams that combine data from different sources and
manipulate it using Reactor’s vast collection of operators. In a Java stream, you can use
a fluent API to process data through operators like map, flatMap, or filter, each of
which builds a new Stream object that keeps the previous step immutable. Similarly,
you can build reactive streams using a fluent API and operators to process the data
received asynchronously.

Besides the standard operators available to Java streams, you can use more power-
ful ones to apply backpressure, handle errors, and increase application resilience. For
example, the retryWhen() and timeout() operators. Operators can
perform actions on a publisher and return a new publisher without modifying the
original one, so you can build functional and immutable data streams with ease.

Project Reactor is the foundation of the Spring reactive stack, which lets you imple-
ment your business logic in terms of Mono<T> and Flux<T>.

The programming model is based on processing streams of data, and the core data types in Project 
Reactor are Flux and Mono. A Flux object is used to process a stream of 0...n elements and a Mono
object is used to process a stream that either is empty or returns at most one element. 
[source,java,attributes]
----
@Test
void testFlux() {
 List<Integer> list = Flux.just(1, 2, 3, 4)
 .filter(n -> n % 2 == 0)
 .map(n -> n * 2)
 .log()
 .collectList().block();
 assertThat(list).containsExactly(4, 8);
}
----

Here is an explanation of the preceding source code:

1. We initiate the stream with the integers 1, 2, 3, and 4 using the static helper method Flux.just().
2. Next, we filter out the odd numbers – we only allow even numbers to proceed through the 
stream. In this test, these are 2 and 4.
3. Next, we transform (or map) the values in the stream by multiplying them by 2, so they become 
4 and 8.
4. Then, we log the data that flows through the stream after the map operation.
5. We use the collectList method to collect all items from the stream into a List, emitted once 
the stream completes.
6. So far, we have only declared the processing of a stream. To actually get the stream processed, 
we need someone to subscribe to it. The final call to the block method will register a subscriber 
that waits for the processing to complete.
7. The resulting list is saved in a member variable named list.
8. We can now wrap up the test by using the assertThat method to assert that list after the 
processing of the stream contains the expected result – the integers 4 and 8.

== Configuring Emedded Server(Netty)
The default and recommended embedded server for reactive applications in Spring
Boot is Reactor Netty, which is built on top of Netty to provide reactive capabilities
within Project Reactor. You can configure it either through properties or by defining a WebServerFactoryCustomizer<NettyReactiveWebServerFactory> component. 

[source,yml,attributes]
----
server:
  port: 9002
  # By default, Spring Boot stops the server immediately after receiving a terminationsignal (SIGTERM). 
  # You can switch to a graceful mode by configuring the server.shut-down property. 
  shutdown: graceful
  netty:
    # How long to wait for a TCP connection to be established with the server
    connection-timeout: 2s
    # How long to wait before closing a TCP connection if no data is transferred
    idle-timeout: 15s 

spring:
  application:
    name: order-service
  lifecycle:
    #    You can also configure the grace period, which is how long the applica-
    # tion can spend processing all the pending requests. After the grace period expires,
    # the application is terminated even if there are still pending requests. By default, the
    # grace period is 30 seconds. 
    timeout-per-shutdown-phase: 15s 
----

== Exposing a REST API with Spring WebFlux
There are two options for defining RESTful endpoints in a Spring WebFlux application: @RestController classes or functional beans (router functions).
=== Using @RestController classes
[source,java,attributes]
----
@RestController
@RequestMapping("orders")
public class OrderController {

    private final OrderService orderService;

    public OrderController(OrderService orderService) {
        this.orderService = orderService;
    }

    @GetMapping
    public Flux<Order> getAllOrders() {
        return orderService.getAllOrders();
    }

    @PostMapping
    public Mono<Order> submitOrder(@RequestBody @Valid OrderRequest orderRequest) {
        return orderService.submitOrder(orderRequest.isbn(), orderRequest.quantity());
    }

}
----

=== Using functional beans (router functions)

== Reactive clients with Spring WebClient
WebClient is the modern alternative to RestTemplate. It provides blocking and
non-blocking I/O, making it the perfect candidate for both imperative and reactive
applications. It can be operated through a functional-style, fluent API that lets you
configure any aspect of the HTTP interaction.

== Resilient applications with Reactive Spring
A popular library for implementing such patterns was Hystrix, developed by Net-
flix, but as of 2018 it entered maintenance mode and will not be developed further.
Resilience4J gained a lot of popularity, filling the void left by Hystrix. Project Reactor,
the Reactive Spring stack foundation, also provides some useful features for resilience.

You can use the Reactor operators to configure timeouts, retries, fallbacks, and
error handling to make the interaction more resilient to any failure in the ser-
vice downstream or due to the network
== Using Reactive Spring
=== Non-blocking persistence using Spring Data for MongoDB
Making the MongoDB-based repositories reactive is very simple:

• Change the base class for the repositories to ReactiveCrudRepository
• Change the custom finder methods to return either a Mono or a Flux object
[source,java,attributes]
----
public interface ProductRepository extends ReactiveCrudRepository<ProductEntity, String> {
    Mono<ProductEntity> findByProductId(int productId);
}
----

When it comes to testing the persistence layer, we have to make some changes. Since our persistence 
methods now return a Mono or Flux object, the test methods have to wait for the response to be avail-
able in the returned reactive objects. The test methods can either use an explicit call to the block()
method on the Mono/Flux object to wait until a response is available, or they can use the StepVerifier
helper class from Project Reactor to declare a verifiable sequence of asynchronous events

[source,java,attributes]
----
ProductEntity foundEntity = repository.findById(newEntity.getId()).get();
assertEqualsProduct(newEntity, foundEntity);
----

We can use the block() method on the Mono object returned by the repository.findById() method 
and keep the imperative programming style, as shown here:
[source,java,attributes]
----
ProductEntity foundEntity = repository.findById(newEntity.getId()).block();
assertEqualsProduct(newEntity, foundEntity);
----
Alternatively, we can use the StepVerifier class to set up a sequence of processing steps that both 
executes the repository find operation and also verifies the result. The sequence is initialized by the 
final call to the verifyComplete() method like this:
[source,java,attributes]
----
StepVerifier.create(repository.findById(newEntity.getId()))
 .expectNextMatches(foundEntity -> areProductEqual(newEntity, foundEntity))
 .verifyComplete();
----
[tabs]
======

CaveatEmptor::
+
[tabs]
====

Country.java::
+
[source, java]
----
----
====

Cities API::
+
[tabs]
====
Country.java::
+
[source, java]
----
----
====

Multiplication microservices::
+
[source, java]
----
----

Microservices with Spring Boot 3 and Spring Cloud::
+
[tabs]
====
ProductRepositoryTest.java::
+
[source, java]
----
package se.magnus.microservices.core.product.persistence;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.dao.OptimisticLockingFailureException;

import reactor.test.StepVerifier;

@DataMongoTest
class ProductRepositoryTest extends MongoDbTestBase {

    @Autowired
    private ProductRepository repository;

    private ProductEntity savedEntity;

    @BeforeEach
    void setupDb() {
        StepVerifier.create(repository.deleteAll()).verifyComplete();

        ProductEntity entity = new ProductEntity(1, "n", 1);
        StepVerifier.create(repository.save(entity))
                .expectNextMatches(createdEntity -> {
                    savedEntity = createdEntity;
                    return areProductEqual(entity, savedEntity);
                })
                .verifyComplete();
    }

    @Test
    void create() {
        ProductEntity newEntity = new ProductEntity(2, "n", 2);

        StepVerifier.create(repository.save(newEntity))
                .expectNextMatches(createdEntity -> newEntity.getProductId() == createdEntity.getProductId())
                .verifyComplete();

        StepVerifier.create(repository.findById(newEntity.getId()))
                .expectNextMatches(foundEntity -> areProductEqual(newEntity, foundEntity))
                .verifyComplete();

        StepVerifier.create(repository.count()).expectNext(2L).verifyComplete();
    }

    @Test
    void update() {
        savedEntity.setName("n2");
        StepVerifier.create(repository.save(savedEntity))
                .expectNextMatches(updatedEntity -> updatedEntity.getName().equals("n2"))
                .verifyComplete();

        StepVerifier.create(repository.findById(savedEntity.getId()))
                .expectNextMatches(foundEntity -> foundEntity.getVersion() == 1
                        && foundEntity.getName().equals("n2"))
                .verifyComplete();
    }

    @Test
    void delete() {
        StepVerifier.create(repository.delete(savedEntity)).verifyComplete();
        StepVerifier.create(repository.existsById(savedEntity.getId())).expectNext(false).verifyComplete();
    }

    @Test
    void getByProductId() {

        StepVerifier.create(repository.findByProductId(savedEntity.getProductId()))
                .expectNextMatches(foundEntity -> areProductEqual(savedEntity, foundEntity))
                .verifyComplete();
    }

    @Test
    void duplicateError() {
        ProductEntity entity = new ProductEntity(savedEntity.getProductId(), "n", 1);
        StepVerifier.create(repository.save(entity)).expectError(DuplicateKeyException.class).verify();
    }

    @Test
    void optimisticLockError() {

        // Store the saved entity in two separate entity objects
        ProductEntity entity1 = repository.findById(savedEntity.getId()).block();
        ProductEntity entity2 = repository.findById(savedEntity.getId()).block();

        // Update the entity using the first entity object
        entity1.setName("n1");
        repository.save(entity1).block();

        // Update the entity using the second entity object.
        // This should fail since the second entity now holds a old version number, i.e.
        // a Optimistic Lock Error
        StepVerifier.create(repository.save(entity2)).expectError(OptimisticLockingFailureException.class).verify();

        // Get the updated entity from the database and verify its new sate
        StepVerifier.create(repository.findById(savedEntity.getId()))
                .expectNextMatches(foundEntity -> foundEntity.getVersion() == 1
                        && foundEntity.getName().equals("n1"))
                .verifyComplete();
    }

    private boolean areProductEqual(ProductEntity expectedEntity, ProductEntity actualEntity) {
        return (expectedEntity.getId().equals(actualEntity.getId()))
                && (expectedEntity.getVersion() == actualEntity.getVersion())
                && (expectedEntity.getProductId() == actualEntity.getProductId())
                && (expectedEntity.getName().equals(actualEntity.getName()))
                && (expectedEntity.getWeight() == actualEntity.getWeight());
    }
}
----

RecommendationRepositoryTest.java::
+
[source, java]
----
package se.magnus.microservices.core.recommendation.persistence;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.hasSize;
import static org.junit.jupiter.api.Assertions.*;

import java.util.List;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.dao.OptimisticLockingFailureException;
import se.magnus.microservices.core.recommendation.persistence.RecommendationEntity;
import se.magnus.microservices.core.recommendation.persistence.RecommendationRepository;

@DataMongoTest
public class RecommendationRepositoryTest extends MongoDbTestBase {

    @Autowired
    private RecommendationRepository repository;

    private RecommendationEntity savedEntity;

    @BeforeEach
    void setupDb() {
        repository.deleteAll().block();

        RecommendationEntity entity = new RecommendationEntity(1, 2, "a", 3, "c");
        savedEntity = repository.save(entity).block();

        assertEqualsRecommendation(entity, savedEntity);
    }

    @Test
    void create() {

        RecommendationEntity newEntity = new RecommendationEntity(1, 3, "a", 3, "c");
        repository.save(newEntity).block();

        RecommendationEntity foundEntity = repository.findById(newEntity.getId()).block();
        assertEqualsRecommendation(newEntity, foundEntity);

        assertEquals(2, (long) repository.count().block());
    }

    @Test
    void update() {
        savedEntity.setAuthor("a2");
        repository.save(savedEntity).block();

        RecommendationEntity foundEntity = repository.findById(savedEntity.getId()).block();
        assertEquals(1, (long) foundEntity.getVersion());
        assertEquals("a2", foundEntity.getAuthor());
    }

    @Test
    void delete() {
        repository.delete(savedEntity).block();
        assertFalse(repository.existsById(savedEntity.getId()).block());
    }

    @Test
    void getByProductId() {
        List<RecommendationEntity> entityList = repository.findByProductId(savedEntity.getProductId()).collectList()
                .block();

        assertThat(entityList, hasSize(1));
        assertEqualsRecommendation(savedEntity, entityList.get(0));
    }

    @Test
    void duplicateError() {
        assertThrows(DuplicateKeyException.class, () -> {
            RecommendationEntity entity = new RecommendationEntity(1, 2, "a", 3, "c");
            repository.save(entity).block();
        });
    }

    @Test
    void optimisticLockError() {

        // Store the saved entity in two separate entity objects
        RecommendationEntity entity1 = repository.findById(savedEntity.getId()).block();
        RecommendationEntity entity2 = repository.findById(savedEntity.getId()).block();

        // Update the entity using the first entity object
        entity1.setAuthor("a1");
        repository.save(entity1).block();

        // Update the entity using the second entity object.
        // This should fail since the second entity now holds an old version number,
        // i.e. an Optimistic Lock Error
        assertThrows(OptimisticLockingFailureException.class, () -> {
            entity2.setAuthor("a2");
            repository.save(entity2).block();
        });

        // Get the updated entity from the database and verify its new sate
        RecommendationEntity updatedEntity = repository.findById(savedEntity.getId()).block();
        assertEquals(1, (int) updatedEntity.getVersion());
        assertEquals("a1", updatedEntity.getAuthor());
    }

    private void assertEqualsRecommendation(RecommendationEntity expectedEntity, RecommendationEntity actualEntity) {
        assertEquals(expectedEntity.getId(), actualEntity.getId());
        assertEquals(expectedEntity.getVersion(), actualEntity.getVersion());
        assertEquals(expectedEntity.getProductId(), actualEntity.getProductId());
        assertEquals(expectedEntity.getRecommendationId(), actualEntity.getRecommendationId());
        assertEquals(expectedEntity.getAuthor(), actualEntity.getAuthor());
        assertEquals(expectedEntity.getRating(), actualEntity.getRating());
        assertEquals(expectedEntity.getContent(), actualEntity.getContent());
    }
}

----
====

Polar Book Shop::
+
[source, java]
----
----
======

=== Non-blocking REST APIs
to make the APIs in the core services non-blocking as well. We need to make the following changes:

• Change the APIs so that they only return reactive data types
+
To make the APIs of the core services reactive, we need to update their methods so that they return 
either a Mono or Flux object.
For example, getProduct() in the product service now returns Mono<Product> instead of a Product
object:
[source,java,attributes]
----
Mono<Product> getProduct(@PathVariable int productId);
----

[tabs]
======

CaveatEmptor::
+
[tabs]
====

Country.java::
+
[source, java]
----
----
====

Cities API::
+
[tabs]
====
Country.java::
+
[source, java]
----
----
====

Multiplication microservices::
+
[source, java]
----
----

Microservices with Spring Boot 3 and Spring Cloud::
+
[tabs]
====
ProductService.java::
+
[source, java]
----
package se.magnus.api.core.product;

import org.springframework.web.bind.annotation.*;

import reactor.core.publisher.Mono;

public interface ProductService {

  /**
   * Sample usage, see below.
   *
   * curl -X POST $HOST:$PORT/product \
   * -H "Content-Type: application/json" --data \
   * '{"productId":123,"name":"product 123","weight":123}'
   *
   * @param body A JSON representation of the new product
   * @return A JSON representation of the newly created product
   */
  @PostMapping(value = "/product", consumes = "application/json", produces = "application/json")
  Mono<Product> createProduct(Product body);

  /**
   * Sample usage: "curl $HOST:$PORT/product/1".
   *
   * @param productId Id of the product
   * @return the product, if found, else null
   */
  @GetMapping(value = "/product/{productId}", produces = "application/json")
  Mono<Product> getProduct(@PathVariable int productId);

  /**
   * Sample usage: "curl -X DELETE $HOST:$PORT/product/1".
   *
   * @param productId Id of the product
   */
  @DeleteMapping(value = "/product/{productId}")
  Mono<Void> deleteProduct(int productId);
}

----

RecommendationService.java::
+
[source, java]
----
package se.magnus.api.core.recommendation;

import java.util.List;
import org.springframework.web.bind.annotation.*;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public interface RecommendationService {

  /**
   * Sample usage, see below.
   *
   * curl -X POST $HOST:$PORT/recommendation \
   * -H "Content-Type: application/json" --data \
   * '{"productId":123,"recommendationId":456,"author":"me","rate":5,"content":"yada,
   * yada, yada"}'
   *
   * @param body A JSON representation of the new recommendation
   * @return A JSON representation of the newly created recommendation
   */
  @PostMapping(value = "/recommendation", consumes = "application/json", produces = "application/json")
  Mono<Recommendation> createRecommendation(Recommendation body);

  /**
   * Sample usage: "curl $HOST:$PORT/recommendation?productId=1".
   *
   * @param productId Id of the product
   * @return the recommendations of the product
   */
  @GetMapping(value = "/recommendation", produces = "application/json")
  Flux<Recommendation> getRecommendations(
      @RequestParam(value = "productId", required = true) int productId);

  Mono<Void> deleteRecommendations(int productId);
}
----

ReviewService.java::
+
[source, java]
----
package se.magnus.api.core.review;

import java.util.List;
import org.springframework.web.bind.annotation.*;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public interface ReviewService {

  /**
   * Sample usage, see below.
   *
   * curl -X POST $HOST:$PORT/review \
   * -H "Content-Type: application/json" --data \
   * '{"productId":123,"reviewId":456,"author":"me","subject":"yada, yada,
   * yada","content":"yada, yada, yada"}'
   *
   * @param body A JSON representation of the new review
   * @return A JSON representation of the newly created review
   */
  @PostMapping(value = "/review", consumes = "application/json", produces = "application/json")
  Mono<Review> createReview(Review body);

  /**
   * Sample usage: "curl $HOST:$PORT/review?productId=1".
   *
   * @param productId Id of the product
   * @return the reviews of the product
   */
  @GetMapping(value = "/review", produces = "application/json")
  Flux<Review> getReviews(@RequestParam(value = "productId", required = true) int productId);

  /**
   * Sample usage: "curl -X DELETE $HOST:$PORT/review?productId=1".
   *
   * @param productId Id of the product
   */
  @DeleteMapping(value = "/review")
  Mono<Void> deleteReviews(int productId);
}
----
====

Polar Book Shop::
+
[source, java]
----
----
======
+
• Change the service implementations so they don’t contain any blocking code
+
we can use the fluent API in Project Reactor. For example, the implementation of the getProduct() method looks like the following code:
[source,java,attributes]
----
  public Mono<Product> getProduct(int productId) {

    if (productId < 1) {
      throw new InvalidInputException("Invalid productId: " + productId);
    }

    LOG.info("Will get product info for id={}", productId);

    return repository.findByProductId(productId)
        .switchIfEmpty(Mono.error(new NotFoundException("No product found for productId: " + productId)))
        .log(LOG.getName(), FINE)
        .map(e -> mapper.entityToApi(e))
        .map(e -> setServiceAddress(e));
  }
----

[tabs]
======

CaveatEmptor::
+
[tabs]
====

Country.java::
+
[source, java]
----
----
====

Cities API::
+
[tabs]
====
Country.java::
+
[source, java]
----
----
====

Multiplication microservices::
+
[source, java]
----
----

Microservices with Spring Boot 3 and Spring Cloud::
+
[tabs]
====
ProductServiceImpl.java::
+
[source, java]
----
package se.magnus.microservices.core.product.services;

import static java.util.logging.Level.FINE;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;
import se.magnus.api.core.product.Product;
import se.magnus.api.core.product.ProductService;
import se.magnus.api.exceptions.InvalidInputException;
import se.magnus.api.exceptions.NotFoundException;
import se.magnus.microservices.core.product.persistence.ProductEntity;
import se.magnus.microservices.core.product.persistence.ProductRepository;
import se.magnus.util.http.ServiceUtil;

@RestController
public class ProductServiceImpl implements ProductService {

  private static final Logger LOG = LoggerFactory.getLogger(ProductServiceImpl.class);

  private final ServiceUtil serviceUtil;

  private final ProductRepository repository;

  private final ProductMapper mapper;

  @Autowired
  public ProductServiceImpl(ProductRepository repository, ProductMapper mapper, ServiceUtil serviceUtil) {
    this.repository = repository;
    this.mapper = mapper;
    this.serviceUtil = serviceUtil;
  }

  @Override
  public Mono<Product> createProduct(Product body) {

    if (body.getProductId() < 1) {
      throw new InvalidInputException("Invalid productId: " + body.getProductId());
    }

    ProductEntity entity = mapper.apiToEntity(body);
    Mono<Product> newEntity = repository.save(entity)
        .log(LOG.getName(), FINE)
        .onErrorMap(
            DuplicateKeyException.class,
            ex -> new InvalidInputException("Duplicate key, Product Id: " + body.getProductId()))
        .map(e -> mapper.entityToApi(e));

    return newEntity;
  }

  @Override
  public Mono<Product> getProduct(int productId) {

    if (productId < 1) {
      throw new InvalidInputException("Invalid productId: " + productId);
    }

    LOG.info("Will get product info for id={}", productId);

    return repository.findByProductId(productId)
        .switchIfEmpty(Mono.error(new NotFoundException("No product found for productId: " + productId)))
        .log(LOG.getName(), FINE)
        .map(e -> mapper.entityToApi(e))
        .map(e -> setServiceAddress(e));
  }

  @Override
  public Mono<Void> deleteProduct(int productId) {

    if (productId < 1) {
      throw new InvalidInputException("Invalid productId: " + productId);
    }

    LOG.debug("deleteProduct: tries to delete an entity with productId: {}", productId);
    return repository.findByProductId(productId).log(LOG.getName(), FINE).map(e -> repository.delete(e))
        .flatMap(e -> e);
  }

  private Product setServiceAddress(Product e) {
    e.setServiceAddress(serviceUtil.getServiceAddress());
    return e;
  }
}
----

RecommendationServiceImpl.java::
+
[source, java]
----
package se.magnus.microservices.core.recommendation.services;

import static java.util.logging.Level.FINE;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import se.magnus.api.core.recommendation.Recommendation;
import se.magnus.api.core.recommendation.RecommendationService;
import se.magnus.api.exceptions.InvalidInputException;
import se.magnus.microservices.core.recommendation.persistence.RecommendationEntity;
import se.magnus.microservices.core.recommendation.persistence.RecommendationRepository;
import se.magnus.util.http.ServiceUtil;

@RestController
public class RecommendationServiceImpl implements RecommendationService {

    private static final Logger LOG = LoggerFactory.getLogger(RecommendationServiceImpl.class);

    private final RecommendationRepository repository;

    private final RecommendationMapper mapper;

    private final ServiceUtil serviceUtil;

    @Autowired
    public RecommendationServiceImpl(RecommendationRepository repository, RecommendationMapper mapper,
            ServiceUtil serviceUtil) {
        this.repository = repository;
        this.mapper = mapper;
        this.serviceUtil = serviceUtil;
    }

    @Override
    public Mono<Recommendation> createRecommendation(Recommendation body) {

        if (body.getProductId() < 1) {
            throw new InvalidInputException("Invalid productId: " + body.getProductId());
        }

        RecommendationEntity entity = mapper.apiToEntity(body);
        Mono<Recommendation> newEntity = repository.save(entity)
                .log(LOG.getName(), FINE)
                .onErrorMap(
                        DuplicateKeyException.class,
                        ex -> new InvalidInputException("Duplicate key, Product Id: " + body.getProductId()
                                + ", Recommendation Id:" + body.getRecommendationId()))
                .map(e -> mapper.entityToApi(e));

        return newEntity;
    }

    @Override
    public Flux<Recommendation> getRecommendations(int productId) {

        if (productId < 1) {
            throw new InvalidInputException("Invalid productId: " + productId);
        }

        LOG.info("Will get recommendations for product with id={}", productId);

        return repository.findByProductId(productId)
                .log(LOG.getName(), FINE)
                .map(e -> mapper.entityToApi(e))
                .map(e -> setServiceAddress(e));
    }

    @Override
    public Mono<Void> deleteRecommendations(int productId) {

        if (productId < 1) {
            throw new InvalidInputException("Invalid productId: " + productId);
        }

        LOG.debug("deleteRecommendations: tries to delete recommendations for the product with productId: {}",
                productId);
        return repository.deleteAll(repository.findByProductId(productId));
    }

    private Recommendation setServiceAddress(Recommendation e) {
        e.setServiceAddress(serviceUtil.getServiceAddress());
        return e;
    }
}
----

ReviewServiceImpl.java::
+
[source, java]
----
package se.magnus.microservices.core.review.services;

import static java.util.logging.Level.FINE;

import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Scheduler;
import se.magnus.api.core.review.Review;
import se.magnus.api.core.review.ReviewService;
import se.magnus.api.exceptions.InvalidInputException;
import se.magnus.microservices.core.review.persistence.ReviewEntity;
import se.magnus.microservices.core.review.persistence.ReviewRepository;
import se.magnus.util.http.ServiceUtil;

@RestController
public class ReviewServiceImpl implements ReviewService {

    private static final Logger LOG = LoggerFactory.getLogger(ReviewServiceImpl.class);

    private final ReviewRepository repository;

    private final ReviewMapper mapper;

    private final ServiceUtil serviceUtil;

    private final Scheduler jdbcScheduler;

    @Autowired
    public ReviewServiceImpl(@Qualifier("jdbcScheduler") Scheduler jdbcScheduler, ReviewRepository repository,
            ReviewMapper mapper, ServiceUtil serviceUtil) {
        this.jdbcScheduler = jdbcScheduler;
        this.repository = repository;
        this.mapper = mapper;
        this.serviceUtil = serviceUtil;
    }

    @Override
    public Mono<Review> createReview(Review body) {

        if (body.getProductId() < 1) {
            throw new InvalidInputException("Invalid productId: " + body.getProductId());
        }
        return Mono.fromCallable(() -> internalCreateReview(body))
                .subscribeOn(jdbcScheduler);
    }

    private Review internalCreateReview(Review body) {
        try {
            ReviewEntity entity = mapper.apiToEntity(body);
            ReviewEntity newEntity = repository.save(entity);

            LOG.debug("createReview: created a review entity: {}/{}", body.getProductId(), body.getReviewId());
            return mapper.entityToApi(newEntity);

        } catch (DataIntegrityViolationException dive) {
            throw new InvalidInputException(
                    "Duplicate key, Product Id: " + body.getProductId() + ", Review Id:" + body.getReviewId());
        }
    }

    @Override
    public Flux<Review> getReviews(int productId) {

        if (productId < 1) {
            throw new InvalidInputException("Invalid productId: " + productId);
        }

        LOG.info("Will get reviews for product with id={}", productId);

        return Mono.fromCallable(() -> internalGetReviews(productId))
                .flatMapMany(Flux::fromIterable)
                .log(LOG.getName(), FINE)
                .subscribeOn(jdbcScheduler);
    }

    private List<Review> internalGetReviews(int productId) {

        List<ReviewEntity> entityList = repository.findByProductId(productId);
        List<Review> list = mapper.entityListToApiList(entityList);
        list.forEach(e -> e.setServiceAddress(serviceUtil.getServiceAddress()));

        LOG.debug("Response size: {}", list.size());

        return list;
    }

    @Override
    public Mono<Void> deleteReviews(int productId) {

        if (productId < 1) {
            throw new InvalidInputException("Invalid productId: " + productId);
        }

        return Mono.fromRunnable(() -> internalDeleteReviews(productId)).subscribeOn(jdbcScheduler).then();
    }

    private void internalDeleteReviews(int productId) {

        LOG.debug("deleteReviews: tries to delete reviews for the product with productId: {}", productId);

        repository.deleteAll(repository.findByProductId(productId));
    }
}
----
====

Polar Book Shop::
+
[source, java]
----
----
======
• Change our tests so that they can test the reactive services
+
To handle the asynchronous behavior of the reactive return 
types, Mono and Flux, the tests use a mix of calling the block() method and using the StepVerifier
helper class.
• Deal with blocking code – isolate the code that still needs to be blocking from the non-blocking 
code
[tabs]
======

CaveatEmptor::
+
[tabs]
====

Country.java::
+
[source, java]
----
----
====

Cities API::
+
[tabs]
====
Country.java::
+
[source, java]
----
----
====

Multiplication microservices::
+
[source, java]
----
----

Microservices with Spring Boot 3 and Spring Cloud::
+
[tabs]
====
ProductServiceApplicationTests.java::
+
[source, java]
----
package se.magnus.microservices.core.product;

import static org.junit.Assert.assertNull;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.springframework.boot.test.context.SpringBootTest.WebEnvironment.RANDOM_PORT;
import static org.springframework.http.HttpStatus.*;
import static org.springframework.http.MediaType.APPLICATION_JSON;
import static reactor.core.publisher.Mono.just;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.HttpStatus;
import org.springframework.test.web.reactive.server.WebTestClient;
import se.magnus.api.core.product.Product;
import se.magnus.microservices.core.product.persistence.MongoDbTestBase;
import se.magnus.microservices.core.product.persistence.ProductRepository;

@SpringBootTest(webEnvironment = RANDOM_PORT)
class ProductServiceApplicationTests extends MongoDbTestBase {

	@Autowired
	private WebTestClient client;

	@Autowired
	private ProductRepository repository;

	@BeforeEach
	void setupDb() {
		repository.deleteAll().block();
	}

	@Test
	void getProductById() {

		int productId = 1;

		assertNull(repository.findByProductId(productId).block());
		assertEquals(0, (long) repository.count().block());

		postAndVerifyProduct(productId, OK);

		assertNotNull(repository.findByProductId(productId).block());
		assertEquals(1, (long) repository.count().block());

		getAndVerifyProduct(productId, OK).jsonPath("$.productId").isEqualTo(productId);
	}

	@Test
	void duplicateError() {

		int productId = 1;

		assertNull(repository.findByProductId(productId).block());

		postAndVerifyProduct(productId, OK);

		assertNotNull(repository.findByProductId(productId).block());

		postAndVerifyProduct(productId, UNPROCESSABLE_ENTITY)
				.jsonPath("$.path").isEqualTo("/product")
				.jsonPath("$.message").isEqualTo("Duplicate key, Product Id: " + productId);
	}

	@Test
	void deleteProduct() {

		int productId = 1;

		postAndVerifyProduct(productId, OK);
		assertNotNull(repository.findByProductId(productId).block());

		deleteAndVerifyProduct(productId, OK);
		assertNull(repository.findByProductId(productId).block());

		deleteAndVerifyProduct(productId, OK);
	}

	@Test
	void getProductInvalidParameterString() {

		getAndVerifyProduct("/no-integer", BAD_REQUEST)
				.jsonPath("$.path").isEqualTo("/product/no-integer")
				.jsonPath("$.message").isEqualTo("Type mismatch.");
	}

	@Test
	void getProductNotFound() {

		int productIdNotFound = 13;
		getAndVerifyProduct(productIdNotFound, NOT_FOUND)
				.jsonPath("$.path").isEqualTo("/product/" + productIdNotFound)
				.jsonPath("$.message").isEqualTo("No product found for productId: " + productIdNotFound);
	}

	@Test
	void getProductInvalidParameterNegativeValue() {

		int productIdInvalid = -1;

		getAndVerifyProduct(productIdInvalid, UNPROCESSABLE_ENTITY)
				.jsonPath("$.path").isEqualTo("/product/" + productIdInvalid)
				.jsonPath("$.message").isEqualTo("Invalid productId: " + productIdInvalid);
	}

	private WebTestClient.BodyContentSpec getAndVerifyProduct(int productId, HttpStatus expectedStatus) {
		return getAndVerifyProduct("/" + productId, expectedStatus);
	}

	private WebTestClient.BodyContentSpec getAndVerifyProduct(String productIdPath, HttpStatus expectedStatus) {
		return client.get()
				.uri("/product" + productIdPath)
				.accept(APPLICATION_JSON)
				.exchange()
				.expectStatus().isEqualTo(expectedStatus)
				.expectHeader().contentType(APPLICATION_JSON)
				.expectBody();
	}

	private WebTestClient.BodyContentSpec postAndVerifyProduct(int productId, HttpStatus expectedStatus) {
		Product product = new Product(productId, "Name " + productId, productId, "SA");
		return client.post()
				.uri("/product")
				.body(just(product), Product.class)
				.accept(APPLICATION_JSON)
				.exchange()
				.expectStatus().isEqualTo(expectedStatus)
				.expectHeader().contentType(APPLICATION_JSON)
				.expectBody();
	}

	private WebTestClient.BodyContentSpec deleteAndVerifyProduct(int productId, HttpStatus expectedStatus) {
		return client.delete()
				.uri("/product/" + productId)
				.accept(APPLICATION_JSON)
				.exchange()
				.expectStatus().isEqualTo(expectedStatus)
				.expectBody();
	}
}
----

RecommendationServiceApplicationTests.java::
+
[source, java]
----
package se.magnus.microservices.core.recommendation;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.springframework.boot.test.context.SpringBootTest.WebEnvironment.RANDOM_PORT;
import static org.springframework.http.HttpStatus.*;
import static org.springframework.http.MediaType.APPLICATION_JSON;
import static reactor.core.publisher.Mono.just;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.HttpStatus;
import org.springframework.test.web.reactive.server.WebTestClient;
import se.magnus.api.core.recommendation.Recommendation;
import se.magnus.microservices.core.recommendation.persistence.RecommendationRepository;

import se.magnus.microservices.core.recommendation.persistence.MongoDbTestBase;

@SpringBootTest(webEnvironment = RANDOM_PORT)
class RecommendationServiceApplicationTests extends MongoDbTestBase {

	@Autowired
	private WebTestClient client;

	@Autowired
	private RecommendationRepository repository;

	@BeforeEach
	void setupDb() {
		repository.deleteAll().block();
	}

	@Test
	void getRecommendationsByProductId() {

		int productId = 1;

		postAndVerifyRecommendation(productId, 1, OK);
		postAndVerifyRecommendation(productId, 2, OK);
		postAndVerifyRecommendation(productId, 3, OK);

		assertEquals(3, repository.findByProductId(productId).count().block());

		getAndVerifyRecommendationsByProductId(productId, OK)
				.jsonPath("$.length()").isEqualTo(3)
				.jsonPath("$[2].productId").isEqualTo(productId)
				.jsonPath("$[2].recommendationId").isEqualTo(3);
	}

	@Test
	void duplicateError() {

		int productId = 1;
		int recommendationId = 1;

		postAndVerifyRecommendation(productId, recommendationId, OK)
				.jsonPath("$.productId").isEqualTo(productId)
				.jsonPath("$.recommendationId").isEqualTo(recommendationId);

		assertEquals(1, repository.count().block());

		postAndVerifyRecommendation(productId, recommendationId, UNPROCESSABLE_ENTITY)
				.jsonPath("$.path").isEqualTo("/recommendation")
				.jsonPath("$.message").isEqualTo("Duplicate key, Product Id: 1, Recommendation Id:1");

		assertEquals(1, repository.count().block());
	}

	@Test
	void deleteRecommendations() {

		int productId = 1;
		int recommendationId = 1;

		postAndVerifyRecommendation(productId, recommendationId, OK);
		assertEquals(1, repository.findByProductId(productId).count().block());

		deleteAndVerifyRecommendationsByProductId(productId, OK);
		assertEquals(0, repository.findByProductId(productId).count().block());

		deleteAndVerifyRecommendationsByProductId(productId, OK);
	}

	@Test
	void getRecommendationsMissingParameter() {

		getAndVerifyRecommendationsByProductId("", BAD_REQUEST)
				.jsonPath("$.path").isEqualTo("/recommendation")
				.jsonPath("$.message").isEqualTo("Required query parameter 'productId' is not present.");
	}

	@Test
	void getRecommendationsInvalidParameter() {

		getAndVerifyRecommendationsByProductId("?productId=no-integer", BAD_REQUEST)
				.jsonPath("$.path").isEqualTo("/recommendation")
				.jsonPath("$.message").isEqualTo("Type mismatch.");
	}

	@Test
	void getRecommendationsNotFound() {

		getAndVerifyRecommendationsByProductId("?productId=113", OK)
				.jsonPath("$.length()").isEqualTo(0);
	}

	@Test
	void getRecommendationsInvalidParameterNegativeValue() {

		int productIdInvalid = -1;

		getAndVerifyRecommendationsByProductId("?productId=" + productIdInvalid, UNPROCESSABLE_ENTITY)
				.jsonPath("$.path").isEqualTo("/recommendation")
				.jsonPath("$.message").isEqualTo("Invalid productId: " + productIdInvalid);
	}

	private WebTestClient.BodyContentSpec getAndVerifyRecommendationsByProductId(int productId,
			HttpStatus expectedStatus) {
		return getAndVerifyRecommendationsByProductId("?productId=" + productId, expectedStatus);
	}

	private WebTestClient.BodyContentSpec getAndVerifyRecommendationsByProductId(String productIdQuery,
			HttpStatus expectedStatus) {
		return client.get()
				.uri("/recommendation" + productIdQuery)
				.accept(APPLICATION_JSON)
				.exchange()
				.expectStatus().isEqualTo(expectedStatus)
				.expectHeader().contentType(APPLICATION_JSON)
				.expectBody();
	}

	private WebTestClient.BodyContentSpec postAndVerifyRecommendation(int productId, int recommendationId,
			HttpStatus expectedStatus) {
		Recommendation recommendation = new Recommendation(productId, recommendationId, "Author " + recommendationId,
				recommendationId, "Content " + recommendationId, "SA");
		return client.post()
				.uri("/recommendation")
				.body(just(recommendation), Recommendation.class)
				.accept(APPLICATION_JSON)
				.exchange()
				.expectStatus().isEqualTo(expectedStatus)
				.expectHeader().contentType(APPLICATION_JSON)
				.expectBody();
	}

	private WebTestClient.BodyContentSpec deleteAndVerifyRecommendationsByProductId(int productId,
			HttpStatus expectedStatus) {
		return client.delete()
				.uri("/recommendation?productId=" + productId)
				.accept(APPLICATION_JSON)
				.exchange()
				.expectStatus().isEqualTo(expectedStatus)
				.expectBody();
	}

}
----
====

Polar Book Shop::
+
[source, java]
----
----
======

=== blocking code
When using JPA to access its data in a relational database, we don’t 
have support for a non-blocking programming model. Instead, we can run the blocking code using 
a Scheduler, which is capable of running the blocking code on a thread from a dedicated thread 
pool with a limited number of threads. Using a thread pool for the blocking code avoids draining the 
available threads in the microservice and avoids affecting concurrent non-blocking processing in the 
microservice, if there is any.

1. First, we configure a scheduler bean and its thread pool in the main class of Application, as follows:
+
[source,java,attributes]
----
@Autowired
public ReviewServiceApplication(
 @Value("${app.threadPoolSize:10}") Integer threadPoolSize,
 @Value("${app.taskQueueSize:100}") Integer taskQueueSize
) {
 this.threadPoolSize = threadPoolSize;
 this.taskQueueSize = taskQueueSize;
}
@Bean
public Scheduler jdbcScheduler() {
 return Schedulers.newBoundedElastic(threadPoolSize,
 taskQueueSize, "jdbc-pool");
}
----
+
From the preceding code, we can see that the scheduler bean is named jdbcScheduler and 
that we can configure its thread pool using the following properties:
  • app.threadPoolSize, specifying the max number of threads in the pool; defaults to 10
  • app.taskQueueSize, specifying the max number of tasks that are allowed to be placed 
in a queue waiting for available threads; defaults to 100
2. Next, we inject the scheduler named jdbcScheduler into the review service implementation 
class, as shown here:
+
[source,java,attributes]
----
@RestController
public class ReviewServiceImpl implements ReviewService {
private final Scheduler jdbcScheduler;
 @Autowired
 public ReviewServiceImpl(
 @Qualifier("jdbcScheduler")
 Scheduler jdbcScheduler, ...) {
 this.jdbcScheduler = jdbcScheduler;
 }
----
3. Finally, we use the scheduler’s thread pool in the reactive implementation of the getReviews()
method, like so:
[source,java,attributes]
----
@Override
public Flux<Review> getReviews(int productId) {
 if (productId < 1) {
 throw new InvalidInputException("Invalid productId: " + 
 productId);
 }
 LOG.info("Will get reviews for product with id={}", 
 productId);
 return Mono.fromCallable(() -> internalGetReviews(productId))
 .flatMapMany(Flux::fromIterable)
 .log(LOG.getName(), FINE)
 .subscribeOn(jdbcScheduler);
}
private List<Review> internalGetReviews(int productId) {
 List<ReviewEntity> entityList = repository.
 findByProductId(productId);
 List<Review> list = mapper.entityListToApiList(entityList);
 list.forEach(e -> e.setServiceAddress(serviceUtil.
 getServiceAddress()));
 LOG.debug("Response size: {}", list.size());
 return list;
}
----
+
Here, the blocking code is placed in the internalGetReviews() method and is wrapped 
in a Mono object using the Mono.fromCallable() method. The getReviews() method uses 
the subscribeOn() method to run the blocking code in a thread from the thread pool of 
jdbcScheduler.

we can look at the log output from the review service and 
see proof that SQL statements are run in threads from the scheduler’s dedicated pool. We will be able 
to see log output like this:

images::{figures}/reactive-programmig-blocking-code-log.png[]

From the preceding log output, we can see the following:

• The first log output is from the LOG.info() call in the getReviews() method and it is executed 
on an HTTP thread, named ctor-http-nio-4, a thread used by WebFlux.
• In the second log output, we can see the SQL statement generated by Spring Data JPA, using 
Hibernate under the hood. The SQL statement corresponds to the method call repository.
findByProductId(). It is executed on a thread named jdbc-pool-1, meaning it is executed in 
a thread from the dedicated thread pool for blocking code, as expected!

=== 
=== DEFINING Timeouts FOR WEBCLIENT
Project Reactor provides a timeout() operator you can use to define a time limit for
completing an operation. You can chain it with the result of the WebClient call to continue the reactive stream. 
[source,java,attributes]
----
public Mono<Book> getBookByIsbn(String isbn) {
    return webClient
            .get()
            .uri(BOOKS_ROOT_API + isbn)
            .retrieve()
            .bodyToMono(Book.class)
            // The fallback returns an empty Mono object.
            .timeout(Duration.ofSeconds(3), Mono.empty())
            .onErrorResume(WebClientResponseException.NotFound.class, exception -> Mono.empty())
}
----

=== DEFINING RETRIES FOR WEBCLIENT
Project Reactor provides a retryWhen() operator to retry an operation when it fails.
The position where you apply it to the reactive stream matters.

* Placing the retryWhen() operator after timeout() means that the timeout is
applied to each retry attempt.
* Placing the retryWhen() operator before timeout() means that the timeout is
applied to the overall operation (that is, the whole sequence of the initial
request and retries has to happen within the given time limit).

You can define the number of attempts and the minimum duration for the
first backoff. The delay is computed for each retry as the current attempt number
multiplied by the minimum backoff period. A jitter factor can be used to add random-
ness to the exponential of each backoff. By default, a jitter of at most 50% of the com-
puted delay is used. When you have multiple instances of Order Service running, the
jitter factor ensures that the replicas will not retry requests simultaneously.

[source,java,attributes]
----
public Mono<Book> getBookByIsbn(String isbn) {
    return webClient
            .get()
            .uri(BOOKS_ROOT_API + isbn)
            .retrieve()
            .bodyToMono(Book.class)
            /*
                * Instead of throwing an exception when the timeout expires, you have the
                * chance to pro-
                * vide a fallback behavior. Considering that Order Service can’t accept an
                * order if the
                * book’s availability is not verified, you might consider returning an empty
                * result so that
                * the order will be rejected. You can define a reactive empty result using
                * Mono.empty().
                */
            /*
                * In a real production scenario, you might want to externalize the time out
                * configuration by adding a new field to the ClientProperties.
                * In that way, you can change its value depending on the environment without
                * having to rebuild the application. It’s also essential to monitor any timeout
                * and tune its value if necessary.
                */
            .timeout(Duration.ofSeconds(3), Mono.empty())
            .onErrorResume(WebClientResponseException.NotFound.class, exception -> Mono.empty())
            /*
                * we want the timeout to apply to each retry attempt, so we’ll use
                * the retryWhen() operator after timeout() whic means that the timeout is
                * applied to each retry attempt. The time limiter is applied first. If the
                * timeout expires, the retryWhen()
                * operator kicks in and tries the request again.
                */
                /*
                 * Exponential backoff is used
                 * as the retry strategy. Three
                 * attempts are allowed with
                 * a 100 ms initial backoff
                 */
            .retryWhen(Retry.backoff(3, Duration.ofMillis(100)))
            .onErrorResume(Exception.class, exception -> Mono.empty());
}
----
=== Fallbacks and error handling
Some errors are acceptable and semantically meaningful in the context of your
business logic. When Order Service calls Catalog Service to fetch information about a
specific book, a 404 response might be returned. That’s an acceptable response that
should be addressed to inform the user that the order cannot be submitted because
the book is not available in the catalog.

The retry strategy you defined in the previous section is not limited: it will retry the
request as long as an error response is received, including acceptable ones like 404.
However, in that case, you don’t want to retry the request. Project Reactor provides an
onErrorResume() operator to define a fallback when a specific error occurs. You can
add it to the reactive stream after the timeout() operator and before the retry-
When() so that if a 404 response is received (WebClientResponseException.NotFound
exception), the retry operator is not triggered. Then you can use the same operator
again at the end of the stream to catch any other exception and fall back to an empty
Mono. Update the getBookByIsbn() method in the BookClient class as follows.

[source,java,attributes]
----
public Mono<Book> getBookByIsbn(String isbn) {
    return webClient
            .get()
            .uri(BOOKS_ROOT_API + isbn)
            .retrieve()
            .bodyToMono(Book.class)
            .timeout(Duration.ofSeconds(3), Mono.empty())
            // Returns an empty object when a 404 response is received
            .onErrorResume(WebClientResponseException.NotFound.class, exception -> Mono.empty())
            .retryWhen(Retry.backoff(3, Duration.ofMillis(100)))
            // If any error happens after the 3 retry attempts, catch the exception and return an empty object.
            .onErrorResume(Exception.class, exception -> Mono.empty());
}
----
In a real-world scenario, you would probably want to return some con-
textual information depending on the type of error, instead of always return-
ing an empty object. For example, you could add a reason field to the Order
object to describe why it’s been rejected. Was it because the book is unavail-
able in the catalog or because of network problems? In the second case, you
could inform the user that the order cannot be processed because it’s
momentarily unable to check the book’s availability. A better option would be
to save the order in a pending state, queue the order submission request, and
try it again later, using strategies like  Event-driven architectures

== Using Resilience4J and Spring Cloud Circuit Breaker

== Examples

[tabs]
======
CaveatEmptor::
+
[tabs]
====
Country.java::
+
[source, java]
----
----
====

Cities API::
+
[tabs]
====
Country.java::
+
[source, java]
----
----
====

Multiplication microservices::
+
[source, java]
----
----

Microservices with Spring Boot 3 and Spring Cloud::
+
In this section, we will learn how to develop non-blocking versions of the read APIs. The composite 
service will make reactive, that is, non-blocking, calls in parallel to the three core services. When 
the composite service has received responses from all of the core services, it will create a composite 
response and send it back to the caller. This is illustrated in the following diagram:
+
images::{figures}/Microservices-with-Spring-Boot-and-Spring-Cloud-reactive-rest-api.png
+
ProductRepository and RecommendationRepository look like the following after the change:
public interface ProductRepository extends ReactiveCrudRepository
<ProductEntity, String> {
 Mono<ProductEntity> findByProductId(int productId);
}
public interface RecommendationRepository extends
ReactiveCrudRepository<RecommendationEntity, String> {
 Flux<RecommendationEntity> findByProductId(int productId);
}
No changes are applied to the persistence code for the review service; it will remain blocking using 
the JPA repository.

[tabs]
====
ProductRepository.java::
+
[source, java]
----
package se.magnus.microservices.core.product.persistence;

import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Mono;

public interface ProductRepository extends ReactiveCrudRepository<ProductEntity, String> {
    Mono<ProductEntity> findByProductId(int productId);
}
----

RecommendationRepository.java::
+
[source, java]
----
package se.magnus.microservices.core.recommendation.persistence;

import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux;

public interface RecommendationRepository extends ReactiveCrudRepository<RecommendationEntity, String> {
  Flux<RecommendationEntity> findByProductId(int productId);
}
----

ProductCompositeIntegration.java::
+
[source, java]
----
package se.magnus.microservices.composite.product.services;

import static java.util.logging.Level.FINE;
import static reactor.core.publisher.Flux.empty;
import static se.magnus.api.event.Event.Type.CREATE;
import static se.magnus.api.event.Event.Type.DELETE;

import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.IOException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.actuate.health.Health;
import org.springframework.cloud.stream.function.StreamBridge;
import org.springframework.http.HttpStatus;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Scheduler;
import se.magnus.api.core.product.Product;
import se.magnus.api.core.product.ProductService;
import se.magnus.api.core.recommendation.Recommendation;
import se.magnus.api.core.recommendation.RecommendationService;
import se.magnus.api.core.review.Review;
import se.magnus.api.core.review.ReviewService;
import se.magnus.api.event.Event;
import se.magnus.api.exceptions.InvalidInputException;
import se.magnus.api.exceptions.NotFoundException;
import se.magnus.util.http.HttpErrorInfo;

@Component
public class ProductCompositeIntegration implements ProductService, RecommendationService, ReviewService {

  private static final Logger LOG = LoggerFactory.getLogger(ProductCompositeIntegration.class);

  private final WebClient webClient;
  private final ObjectMapper mapper;

  private final String productServiceUrl;
  private final String recommendationServiceUrl;
  private final String reviewServiceUrl;

  private final StreamBridge streamBridge;

  private final Scheduler publishEventScheduler;

  @Autowired
  public ProductCompositeIntegration(
    @Qualifier("publishEventScheduler") Scheduler publishEventScheduler,

    WebClient.Builder webClient,
    ObjectMapper mapper,
    StreamBridge streamBridge,

    @Value("${app.product-service.host}") String productServiceHost,
    @Value("${app.product-service.port}") int  productServicePort,

    @Value("${app.recommendation-service.host}") String recommendationServiceHost,
    @Value("${app.recommendation-service.port}") int  recommendationServicePort,

    @Value("${app.review-service.host}") String reviewServiceHost,
    @Value("${app.review-service.port}") int  reviewServicePort
  ) {

    this.publishEventScheduler = publishEventScheduler;
    this.webClient = webClient.build();
    this.mapper = mapper;
    this.streamBridge = streamBridge;

    productServiceUrl        = "http://" + productServiceHost + ":" + productServicePort;
    recommendationServiceUrl = "http://" + recommendationServiceHost + ":" + recommendationServicePort;
    reviewServiceUrl         = "http://" + reviewServiceHost + ":" + reviewServicePort;
  }

  @Override
  public Mono<Product> createProduct(Product body) {

    return Mono.fromCallable(() -> {
      sendMessage("products-out-0", new Event(CREATE, body.getProductId(), body));
      return body;
    }).subscribeOn(publishEventScheduler);
  }

  @Override
  public Mono<Product> getProduct(int productId) {
    String url = productServiceUrl + "/product/" + productId;
    LOG.debug("Will call the getProduct API on URL: {}", url);

    return webClient.get().uri(url).retrieve().bodyToMono(Product.class).log(LOG.getName(), FINE).onErrorMap(WebClientResponseException.class, ex -> handleException(ex));
  }

  @Override
  public Mono<Void> deleteProduct(int productId) {

    return Mono.fromRunnable(() -> sendMessage("products-out-0", new Event(DELETE, productId, null)))
      .subscribeOn(publishEventScheduler).then();
  }

  @Override
  public Mono<Recommendation> createRecommendation(Recommendation body) {

    return Mono.fromCallable(() -> {
      sendMessage("recommendations-out-0", new Event(CREATE, body.getProductId(), body));
      return body;
    }).subscribeOn(publishEventScheduler);
  }

  @Override
  public Flux<Recommendation> getRecommendations(int productId) {

    String url = recommendationServiceUrl + "/recommendation?productId=" + productId;

    LOG.debug("Will call the getRecommendations API on URL: {}", url);

    // Return an empty result if something goes wrong to make it possible for the composite service to return partial responses
    return webClient.get().uri(url).retrieve().bodyToFlux(Recommendation.class).log(LOG.getName(), FINE).onErrorResume(error -> empty());
  }

  @Override
  public Mono<Void> deleteRecommendations(int productId) {

    return Mono.fromRunnable(() -> sendMessage("recommendations-out-0", new Event(DELETE, productId, null)))
      .subscribeOn(publishEventScheduler).then();
  }

  @Override
  public Mono<Review> createReview(Review body) {

    return Mono.fromCallable(() -> {
      sendMessage("reviews-out-0", new Event(CREATE, body.getProductId(), body));
      return body;
    }).subscribeOn(publishEventScheduler);
  }

  @Override
  public Flux<Review> getReviews(int productId) {

    String url = reviewServiceUrl + "/review?productId=" + productId;

    LOG.debug("Will call the getReviews API on URL: {}", url);

    // Return an empty result if something goes wrong to make it possible for the composite service to return partial responses
    return webClient.get().uri(url).retrieve().bodyToFlux(Review.class).log(LOG.getName(), FINE).onErrorResume(error -> empty());
  }

  @Override
  public Mono<Void> deleteReviews(int productId) {

    return Mono.fromRunnable(() -> sendMessage("reviews-out-0", new Event(DELETE, productId, null)))
      .subscribeOn(publishEventScheduler).then();
  }

  public Mono<Health> getProductHealth() {
    return getHealth(productServiceUrl);
  }

  public Mono<Health> getRecommendationHealth() {
    return getHealth(recommendationServiceUrl);
  }

  public Mono<Health> getReviewHealth() {
    return getHealth(reviewServiceUrl);
  }

  private Mono<Health> getHealth(String url) {
    url += "/actuator/health";
    LOG.debug("Will call the Health API on URL: {}", url);
    return webClient.get().uri(url).retrieve().bodyToMono(String.class)
      .map(s -> new Health.Builder().up().build())
      .onErrorResume(ex -> Mono.just(new Health.Builder().down(ex).build()))
      .log(LOG.getName(), FINE);
  }

  private void sendMessage(String bindingName, Event event) {
    LOG.debug("Sending a {} message to {}", event.getEventType(), bindingName);
    Message message = MessageBuilder.withPayload(event)
      .setHeader("partitionKey", event.getKey())
      .build();
    streamBridge.send(bindingName, message);
  }

  private Throwable handleException(Throwable ex) {

    if (!(ex instanceof WebClientResponseException)) {
      LOG.warn("Got a unexpected error: {}, will rethrow it", ex.toString());
      return ex;
    }

    WebClientResponseException wcre = (WebClientResponseException)ex;

    switch (HttpStatus.resolve(wcre.getStatusCode().value())) {

      case NOT_FOUND:
        return new NotFoundException(getErrorMessage(wcre));

      case UNPROCESSABLE_ENTITY:
        return new InvalidInputException(getErrorMessage(wcre));

      default:
        LOG.warn("Got an unexpected HTTP error: {}, will rethrow it", wcre.getStatusCode());
        LOG.warn("Error body: {}", wcre.getResponseBodyAsString());
        return ex;
    }
  }

  private String getErrorMessage(WebClientResponseException ex) {
    try {
      return mapper.readValue(ex.getResponseBodyAsString(), HttpErrorInfo.class).getMessage();
    } catch (IOException ioex) {
      return ex.getMessage();
    }
  }
}
----
ProductCompositeServiceImpl.java(non synchronous)::
+
[source, java]
----
package se.magnus.microservices.composite.product.services;

import static java.util.logging.Level.FINE;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;
import se.magnus.api.composite.product.*;
import se.magnus.api.core.product.Product;
import se.magnus.api.core.recommendation.Recommendation;
import se.magnus.api.core.review.Review;
import se.magnus.util.http.ServiceUtil;

@RestController
public class ProductCompositeServiceImpl implements ProductCompositeService {

  private static final Logger LOG = LoggerFactory.getLogger(ProductCompositeServiceImpl.class);

  private final ServiceUtil serviceUtil;
  private final ProductCompositeIntegration integration;

  @Autowired
  public ProductCompositeServiceImpl(ServiceUtil serviceUtil, ProductCompositeIntegration integration) {
    this.serviceUtil = serviceUtil;
    this.integration = integration;
  }

  @Override
  public Mono<Void> createProduct(ProductAggregate body) {

    try {

      List<Mono> monoList = new ArrayList<>();

      LOG.info("Will create a new composite entity for product.id: {}", body.getProductId());

      Product product = new Product(body.getProductId(), body.getName(), body.getWeight(), null);
      monoList.add(integration.createProduct(product));

      if (body.getRecommendations() != null) {
        body.getRecommendations().forEach(r -> {
          Recommendation recommendation = new Recommendation(body.getProductId(), r.getRecommendationId(), r.getAuthor(), r.getRate(), r.getContent(), null);
          monoList.add(integration.createRecommendation(recommendation));
        });
      }

      if (body.getReviews() != null) {
        body.getReviews().forEach(r -> {
          Review review = new Review(body.getProductId(), r.getReviewId(), r.getAuthor(), r.getSubject(), r.getContent(), null);
          monoList.add(integration.createReview(review));
        });
      }

      LOG.debug("createCompositeProduct: composite entities created for productId: {}", body.getProductId());

      return Mono.zip(r -> "", monoList.toArray(new Mono[0]))
        .doOnError(ex -> LOG.warn("createCompositeProduct failed: {}", ex.toString()))
        .then();

    } catch (RuntimeException re) {
      LOG.warn("createCompositeProduct failed: {}", re.toString());
      throw re;
    }
  }

  @Override
  public Mono<ProductAggregate> getProduct(int productId) {

    LOG.info("Will get composite product info for product.id={}", productId);
    return Mono.zip(
      values -> createProductAggregate((Product) values[0], (List<Recommendation>) values[1], (List<Review>) values[2], serviceUtil.getServiceAddress()),
      integration.getProduct(productId),
      integration.getRecommendations(productId).collectList(),
      integration.getReviews(productId).collectList())
      .doOnError(ex -> LOG.warn("getCompositeProduct failed: {}", ex.toString()))
      .log(LOG.getName(), FINE);
  }

  @Override
  public Mono<Void> deleteProduct(int productId) {

    try {

      LOG.info("Will delete a product aggregate for product.id: {}", productId);

      return Mono.zip(
        r -> "",
        integration.deleteProduct(productId),
        integration.deleteRecommendations(productId),
        integration.deleteReviews(productId))
        .doOnError(ex -> LOG.warn("delete failed: {}", ex.toString()))
        .log(LOG.getName(), FINE).then();

    } catch (RuntimeException re) {
      LOG.warn("deleteCompositeProduct failed: {}", re.toString());
      throw re;
    }
  }

  private ProductAggregate createProductAggregate(Product product, List<Recommendation> recommendations, List<Review> reviews, String serviceAddress) {

    // 1. Setup product info
    int productId = product.getProductId();
    String name = product.getName();
    int weight = product.getWeight();

    // 2. Copy summary recommendation info, if available
    List<RecommendationSummary> recommendationSummaries = (recommendations == null) ? null :
       recommendations.stream()
        .map(r -> new RecommendationSummary(r.getRecommendationId(), r.getAuthor(), r.getRate(), r.getContent()))
        .collect(Collectors.toList());

    // 3. Copy summary review info, if available
    List<ReviewSummary> reviewSummaries = (reviews == null)  ? null :
      reviews.stream()
        .map(r -> new ReviewSummary(r.getReviewId(), r.getAuthor(), r.getSubject(), r.getContent()))
        .collect(Collectors.toList());

    // 4. Create info regarding the involved microservices addresses
    String productAddress = product.getServiceAddress();
    String reviewAddress = (reviews != null && reviews.size() > 0) ? reviews.get(0).getServiceAddress() : "";
    String recommendationAddress = (recommendations != null && recommendations.size() > 0) ? recommendations.get(0).getServiceAddress() : "";
    ServiceAddresses serviceAddresses = new ServiceAddresses(serviceAddress, productAddress, reviewAddress, recommendationAddress);

    return new ProductAggregate(productId, name, weight, recommendationSummaries, reviewSummaries, serviceAddresses);
  }
}
----
====
Polar Book Shop::
+
[source, java]
----
----
======