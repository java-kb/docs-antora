= Spring Rest API
:figures: 11-development/02-spring/03-web

After implementing the business logic, we can expose the use cases through a REST
API. 

== defining REST endpoints

=== using @RestController classes
The first step is to define the REST endpoints. In Spring, you can do that by using
@RestController classes or by using router functions. The first approach is more
common, but the second one is more functional and declarative. The choice is a matter
of preference, and both approaches are valid.
[source,java,attributes]
----
import org.springframework.web.bind.annotation.*;
import java.util.List;  
import java.util.Optional;
@RestController
@RequestMapping("/books")
public class BookController {
    private final BookService bookService;

    public BookController(BookService bookService) {
        this.bookService = bookService;
    }

    @GetMapping
    public List<Book> getAll() {
        return bookService.getAllBooks();
    }

    @GetMapping("/{id}")
    public Optional<Book> getById(@PathVariable Long id) {
        return bookService.getBookById(id);
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Book post(@RequestBody Book book) {
        return bookService.addBookToCatalog(book);
    }

    @PutMapping("/{id}")
    public Book put(@PathVariable Long id, @RequestBody Book book) {
        return bookService.updateBookInCatalog(id, book);
    }

    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void delete(@PathVariable Long id) {
        bookService.deleteBookFromCatalog(id);
    }
}   
----

The @RestController annotation is a convenience annotation that combines the
@Controller and @ResponseBody annotations. It indicates that the class is a controller
and that the methods return JSON responses instead of views. The @RequestMapping
annotation specifies the base path for the endpoints in the controller. The @GetMapping,
@PostMapping, @PutMapping, and @DeleteMapping annotations are used to map the
methods to the corresponding HTTP methods. The @PathVariable annotation is used
to extract the path variable from the URL, and the @RequestBody annotation is used to
bind the request body to a method parameter.    

=== using @RequestMapping
The @RequestMapping annotation is used to map HTTP requests to handler methods
in a controller. It can be used at the class level to define a base path for all
endpoints in the controller or at the method level to define a specific path for a
particular endpoint. The @RequestMapping annotation can also be used to specify the
HTTP method for the endpoint, such as GET, POST, PUT, or DELETE.
[source,java,attributes]
----
import org.springframework.web.bind.annotation.*;
import java.util.List;
@RestController
@RequestMapping("/books")
public class BookController {
    private final BookService bookService;  
    public BookController(BookService bookService) {
        this.bookService = bookService;
    }
    @RequestMapping(method = RequestMethod.GET)
    public List<Book> getAll() {
        return bookService.getAllBooks();
    }
    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    public Optional<Book> getById(@PathVariable Long id) {
        return bookService.getBookById(id);
    }
    @RequestMapping(method = RequestMethod.POST)
    @ResponseStatus(HttpStatus.CREATED)
    public Book post(@RequestBody Book book) {
        return bookService.addBookToCatalog(book);
    }
    @RequestMapping(value = "/{id}", method = RequestMethod.PUT)
    public Book put(@PathVariable Long id, @RequestBody Book book) {
        return bookService.updateBookInCatalog(id, book);
    }
    @RequestMapping(value = "/{id}", method = RequestMethod.DELETE)
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void delete(@PathVariable Long id) {
        bookService.deleteBookFromCatalog(id);
    }
}
----
The @RequestMapping annotation can also be used to specify additional attributes,
such as the consumes and produces attributes, which define the media types that the
endpoint can consume and produce, respectively. This is useful for defining the content
type of the request and response bodies, such as application/json or application/xml.

=== using @GetMapping, @PostMapping, @PutMapping, and @DeleteMapping

=== using router functions
The router functions are a more functional and declarative way to define REST
endpoints in Spring. They are based on the functional programming paradigm and
allow you to define the endpoints using a fluent API. The router functions are defined
in a separate class, and they can be used to define the endpoints in a more concise
way. The router functions are defined using the RouterFunction interface, which 
allows you to define the endpoints using a functional style. The router functions can
be used to define the endpoints in a more concise way, and they can be used to define
the endpoints in a more declarative way. 
[source,java,attributes]
----
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.server.RouterFunction;     
import org.springframework.web.reactive.function.server.ServerResponse;
import org.springframework.web.reactive.function.server.RequestPredicates;
import org.springframework.web.reactive.function.server.RouterFunctions;
import org.springframework.web.reactive.function.server.ServerRequest;
import java.util.List;
import java.util.Optional;

@Configuration
public class BookRouter {
    private final BookService bookService;
    public BookRouter(BookService bookService) {
        this.bookService = bookService;
    }
    @Bean
    public RouterFunction<ServerResponse> bookRoutes() {
        return RouterFunctions.route()
                .GET("/books", this::getAllBooks)
                .GET("/books/{id}", this::getBookById)
                .POST("/books", this::addBookToCatalog)
                .PUT("/books/{id}", this::updateBookInCatalog)
                .DELETE("/books/{id}", this::deleteBookFromCatalog)
                .build();
    }       
    private ServerResponse getAllBooks(ServerRequest request) {
        List<Book> books = bookService.getAllBooks();
        return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).bodyValue(books);
    }
    private ServerResponse getBookById(ServerRequest request) {
        Long id = Long.valueOf(request.pathVariable("id"));
        Optional<Book> book = bookService.getBookById(id);
        return book.map(b -> ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).bodyValue(b))
                .orElseGet(() -> ServerResponse.notFound().build());
    }
    private ServerResponse addBookToCatalog(ServerRequest request) {
        return request.bodyToMono(Book.class)
                .flatMap(book -> bookService.addBookToCatalog(book))
                .flatMap(savedBook -> ServerResponse.created(URI.create("/books/" + savedBook.getId()))
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(savedBook))
                .switchIfEmpty(ServerResponse.badRequest().build());
    }
    private ServerResponse updateBookInCatalog(ServerRequest request) {
        Long id = Long.valueOf(request.pathVariable("id")); 
        return request.bodyToMono(Book.class)
                .flatMap(book -> bookService.updateBookInCatalog(id, book))
                .flatMap(updatedBook -> ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).bodyValue(updatedBook))
                .switchIfEmpty(ServerResponse.notFound().build());
    }
    private ServerResponse deleteBookFromCatalog(ServerRequest request) {
        Long id = Long.valueOf(request.pathVariable("id"));
        bookService.deleteBookFromCatalog(id);
        return ServerResponse.noContent().build();
    }
}
----
The router functions are defined using the RouterFunctions.route() method, which
returns a RouterFunction object. The endpoints are defined using the GET, POST,
PUT, and DELETE methods, which return a ServerResponse object. The ServerResponse
object is used to define the response body and the HTTP status code. The request
body is bound to a Book object using the bodyToMono() method, which returns a Mono
object that represents the request body. The response body is returned using the
bodyValue() method, which returns a ServerResponse object that contains the response
body and the HTTP status code. The switchIfEmpty() method is used to handle the case
where the request body is empty or the response body is not found. The router functions 
can also be used to define the media types that the endpoint can consume and produce,
using the contentType() method. This is useful for defining the content type of the
request and response bodies, such as application/json or application/xml.

== Data validation and error handling
As a general rule, before saving any data, you should always validate the content, both
for data consistency and security reasons. 

Java Bean Validation is a popular specification for expressing constraints and valida-
tion rules on Java objects via annotations. Spring Boot provides a convenient starter
dependency containing the Java Bean Validation API and its implementation(spring-boot-starter-validation).
[source,java,attributes]
----
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Positive;
public record Book(

        @Id Long id,

        @NotBlank(message = "The book ISBN must be defined.") @Pattern(regexp = "^([0-9]{10}|[0-9]{13})$", message = "The ISBN format must be valid.") String isbn,

        @NotBlank(message = "The book title must be defined.") String title,

        @NotBlank(message = "The book author must be defined.") String author,

        @NotNull(message = "The book price must be defined.") @Positive(message = "The book price must be greater than zero.") Double price,

        String publisher,

        @CreatedDate Instant createdDate,

        @LastModifiedDate Instant lastModifiedDate,

        @Version int version

) {
    // For convenience, let’s add a static factory method to the Book record for
    // building an object by passing only the business fields.

    public static Book of(String isbn, String title, String author, Double price, String publisher) {
        return new Book(null, isbn, title, author, price, publisher, null, null, 0);
    }

}c
----

The annotations from the Java Bean Validation API define the constraints, but they
are not enforced yet. We can instruct Spring to validate the Book object in the Book-
Controller class by using the @Valid annotation whenever a @RequestBody is speci-
fied as a method argument.
[source,java,attributes]
----
@PostMapping
@ResponseStatus(HttpStatus.CREATED)
public Book post(@Valid @RequestBody Book book) {
 return bookService.addBookToCatalog(book);
}
----
When building an API, it’s
good to consider which types of errors it can throw, since they are just as important as
the domain data. When it’s a REST API, you want to ensure that the HTTP response
uses a status code that best fits the purpose and includes a meaningful message to
help the client identify the problem.

To handle errors for a REST API, we can use the standard Java exceptions and rely
on a @RestControllerAdvice class to define what to do when a given exception is
thrown. It’s a centralized approach that allows us to decouple the exception handling
from the code throwing the exception. 
[source,java,attributes] 
----
@RestControllerAdvice
public class BookControllerAdvice {
 @ExceptionHandler(BookNotFoundException.class)
    // Defines the status code for the HTTP response created when the exception is
    // thrown
    @ResponseStatus(HttpStatus.NOT_FOUND)
    String bookNotFoundHandler(BookNotFoundException ex) {
        // The message that will be included in the HTTP response body
        return ex.getMessage();
    }

    @ExceptionHandler(BookAlreadyExistsException.class)
    @ResponseStatus(HttpStatus.UNPROCESSABLE_ENTITY)
    String bookAlreadyExistsHandler(BookAlreadyExistsException ex) {
        return ex.getMessage();
    }

    // Handles the exception thrown when the Book validation fails
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public Map<String, String> handleValidationExceptions(MethodArgumentNotValidException ex) {
        // Collects meaningful error messages about which Book fields were invalid
        // instead of returning an empty message
        var errors = new HashMap<String, String>();
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        return errors;
    }

----

== Documenting the Endpoints
One of the biggest problems when using another REST API is knowing information 
about the endpoints like the URL, request/response, and HTTP method. There are 
different methods to document all this information. The default standard is OpenAPI 
Specification.8

Frameworks like Spring Boot and Quarkus offer libraries to document the 
endpoints and dynamically generate the documentation
==  Evolving APIs for future requirements
In a distributed system, we need a plan to evolve APIs so we don’t break the functionality
of other applications. This is a challenging task because we want independent applica-
tions, but they probably exist to provide services to other applications, so we are some-
what limited in the number of changes we can make independently of the clients.

The best approach is to make backward-compatible changes to the API. For exam-
ple, we can add an optional field to the Book object without affecting the clients of the
Catalog Service application.

=== Using API versioning
When breaking changes are necessary, you can use API versioning. The version might be part of the endpoint itself, like /v2/books. Or it
might be specified as an HTTP header. This system helps prevent existing clients from
breaking, but they will have to update their interface to match the new API version
sooner or later, meaning that coordination is needed.

=== Using HATEOAS
A different approach focuses on making the REST API client as resilient to API
changes as possible. The solution is to use the hypermedia aspect of the REST architec-
ture, This hypermedia aspect is also called HATEOAS (Hypermedia as the Engine of
Application State). REST APIs can return the object requested
along with information about where to go next and links to perform related operations.
The beauty of this feature is that the links are only shown when it makes sense to fol-
low them, providing information about when to go.

Spring provides the Spring HATEOAS project to add
hypermedia support to a REST API.

== Examples
[tabs]
======
CaveatEmptor::
+
[tabs]
====
Country.java::
+
[source, java]
----
----
====
Cities API::
+
[tabs]
====
Country.java::
+
[source, java]
----
----
====
Multiplication microservices::
+
[source, java]
----
----
Microservices with Spring Boot 3 and Spring Cloud::
+
[tabs]
====
ProductCompositeIntegration.java(synchronous)::
+
[source, java]
----
package se.magnus.microservices.composite.product.services;

import static org.springframework.http.HttpMethod.GET;

import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;
import se.magnus.api.core.product.Product;
import se.magnus.api.core.product.ProductService;
import se.magnus.api.core.recommendation.Recommendation;
import se.magnus.api.core.recommendation.RecommendationService;
import se.magnus.api.core.review.Review;
import se.magnus.api.core.review.ReviewService;
import se.magnus.api.exceptions.InvalidInputException;
import se.magnus.api.exceptions.NotFoundException;
import se.magnus.util.http.HttpErrorInfo;

@Component
public class ProductCompositeIntegration implements ProductService, RecommendationService, ReviewService {

  private static final Logger LOG = LoggerFactory.getLogger(ProductCompositeIntegration.class);

  private final RestTemplate restTemplate;
  private final ObjectMapper mapper;

  private final String productServiceUrl;
  private final String recommendationServiceUrl;
  private final String reviewServiceUrl;

  @Autowired
  public ProductCompositeIntegration(
    RestTemplate restTemplate,
    ObjectMapper mapper,
    @Value("${app.product-service.host}") String productServiceHost,
    @Value("${app.product-service.port}") int productServicePort,
    @Value("${app.recommendation-service.host}") String recommendationServiceHost,
    @Value("${app.recommendation-service.port}") int recommendationServicePort,
    @Value("${app.review-service.host}") String reviewServiceHost,
    @Value("${app.review-service.port}") int reviewServicePort) {

    this.restTemplate = restTemplate;
    this.mapper = mapper;

    productServiceUrl = "http://" + productServiceHost + ":" + productServicePort + "/product";
    recommendationServiceUrl = "http://" + recommendationServiceHost + ":" + recommendationServicePort + "/recommendation";
    reviewServiceUrl = "http://" + reviewServiceHost + ":" + reviewServicePort + "/review";
  }

  @Override
  public Product createProduct(Product body) {

    try {
      String url = productServiceUrl;
      LOG.debug("Will post a new product to URL: {}", url);

      Product product = restTemplate.postForObject(url, body, Product.class);
      LOG.debug("Created a product with id: {}", product.getProductId());

      return product;

    } catch (HttpClientErrorException ex) {
      throw handleHttpClientException(ex);
    }
  }

  @Override
  public Product getProduct(int productId) {

    try {
      String url = productServiceUrl + "/" + productId;
      LOG.debug("Will call the getProduct API on URL: {}", url);

      Product product = restTemplate.getForObject(url, Product.class);
      LOG.debug("Found a product with id: {}", product.getProductId());

      return product;

    } catch (HttpClientErrorException ex) {
      throw handleHttpClientException(ex);
    }
  }

  @Override
  public void deleteProduct(int productId) {
    try {
      String url = productServiceUrl + "/" + productId;
      LOG.debug("Will call the deleteProduct API on URL: {}", url);

      restTemplate.delete(url);

    } catch (HttpClientErrorException ex) {
      throw handleHttpClientException(ex);
    }
  }

  @Override
  public Recommendation createRecommendation(Recommendation body) {

    try {
      String url = recommendationServiceUrl;
      LOG.debug("Will post a new recommendation to URL: {}", url);

      Recommendation recommendation = restTemplate.postForObject(url, body, Recommendation.class);
      LOG.debug("Created a recommendation with id: {}", recommendation.getProductId());

      return recommendation;

    } catch (HttpClientErrorException ex) {
      throw handleHttpClientException(ex);
    }
  }

  @Override
  public List<Recommendation> getRecommendations(int productId) {

    try {
      String url = recommendationServiceUrl + "?productId=" + productId;

      LOG.debug("Will call the getRecommendations API on URL: {}", url);
      List<Recommendation> recommendations = restTemplate
        .exchange(url, GET, null, new ParameterizedTypeReference<List<Recommendation>>() {})
        .getBody();

      LOG.debug("Found {} recommendations for a product with id: {}", recommendations.size(), productId);
      return recommendations;

    } catch (Exception ex) {
      LOG.warn("Got an exception while requesting recommendations, return zero recommendations: {}", ex.getMessage());
      return new ArrayList<>();
    }
  }

  @Override
  public void deleteRecommendations(int productId) {
    try {
      String url = recommendationServiceUrl + "?productId=" + productId;
      LOG.debug("Will call the deleteRecommendations API on URL: {}", url);

      restTemplate.delete(url);

    } catch (HttpClientErrorException ex) {
      throw handleHttpClientException(ex);
    }
  }

  @Override
  public Review createReview(Review body) {

    try {
      String url = reviewServiceUrl;
      LOG.debug("Will post a new review to URL: {}", url);

      Review review = restTemplate.postForObject(url, body, Review.class);
      LOG.debug("Created a review with id: {}", review.getProductId());

      return review;

    } catch (HttpClientErrorException ex) {
      throw handleHttpClientException(ex);
    }
  }

  @Override
  public List<Review> getReviews(int productId) {

    try {
      String url = reviewServiceUrl + "?productId=" + productId;

      LOG.debug("Will call the getReviews API on URL: {}", url);
      List<Review> reviews = restTemplate
        .exchange(url, GET, null, new ParameterizedTypeReference<List<Review>>() {})
        .getBody();

      LOG.debug("Found {} reviews for a product with id: {}", reviews.size(), productId);
      return reviews;

    } catch (Exception ex) {
      LOG.warn("Got an exception while requesting reviews, return zero reviews: {}", ex.getMessage());
      return new ArrayList<>();
    }
  }

  @Override
  public void deleteReviews(int productId) {
    try {
      String url = reviewServiceUrl + "?productId=" + productId;
      LOG.debug("Will call the deleteReviews API on URL: {}", url);

      restTemplate.delete(url);

    } catch (HttpClientErrorException ex) {
      throw handleHttpClientException(ex);
    }
  }

  private RuntimeException handleHttpClientException(HttpClientErrorException ex) {
    switch (HttpStatus.resolve(ex.getStatusCode().value())) {

      case NOT_FOUND:
        return new NotFoundException(getErrorMessage(ex));

      case UNPROCESSABLE_ENTITY:
        return new InvalidInputException(getErrorMessage(ex));

      default:
        LOG.warn("Got an unexpected HTTP error: {}, will rethrow it", ex.getStatusCode());
        LOG.warn("Error body: {}", ex.getResponseBodyAsString());
        return ex;
    }
  }

  private String getErrorMessage(HttpClientErrorException ex) {
    try {
      return mapper.readValue(ex.getResponseBodyAsString(), HttpErrorInfo.class).getMessage();
    } catch (IOException ioex) {
      return ex.getMessage();
    }
  }
}
----
ProductCompositeServiceImpl.java(synchronous)::
+
[source, java]
----
package se.magnus.microservices.composite.product.services;

import java.util.List;
import java.util.stream.Collectors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import se.magnus.api.composite.product.*;
import se.magnus.api.core.product.Product;
import se.magnus.api.core.recommendation.Recommendation;
import se.magnus.api.core.review.Review;
import se.magnus.api.exceptions.NotFoundException;
import se.magnus.util.http.ServiceUtil;

@RestController
public class ProductCompositeServiceImpl implements ProductCompositeService {

  private static final Logger LOG = LoggerFactory.getLogger(ProductCompositeServiceImpl.class);

  private final ServiceUtil serviceUtil;
  private ProductCompositeIntegration integration;

  @Autowired
  public ProductCompositeServiceImpl(
    ServiceUtil serviceUtil, ProductCompositeIntegration integration) {
    
    this.serviceUtil = serviceUtil;
    this.integration = integration;
  }

  @Override
  public void createProduct(ProductAggregate body) {

    try {

      LOG.debug("createCompositeProduct: creates a new composite entity for productId: {}", body.getProductId());

      Product product = new Product(body.getProductId(), body.getName(), body.getWeight(), null);
      integration.createProduct(product);

      if (body.getRecommendations() != null) {
        body.getRecommendations().forEach(r -> {
          Recommendation recommendation = new Recommendation(body.getProductId(), r.getRecommendationId(), r.getAuthor(), r.getRate(), r.getContent(), null);
          integration.createRecommendation(recommendation);
        });
      }

      if (body.getReviews() != null) {
        body.getReviews().forEach(r -> {
          Review review = new Review(body.getProductId(), r.getReviewId(), r.getAuthor(), r.getSubject(), r.getContent(), null);
          integration.createReview(review);
        });
      }

      LOG.debug("createCompositeProduct: composite entities created for productId: {}", body.getProductId());

    } catch (RuntimeException re) {
      LOG.warn("createCompositeProduct failed", re);
      throw re;
    }
  }


  @Override
  public ProductAggregate getProduct(int productId) {

    LOG.debug("getCompositeProduct: lookup a product aggregate for productId: {}", productId);

    Product product = integration.getProduct(productId);
    if (product == null) {
      throw new NotFoundException("No product found for productId: " + productId);
    }

    List<Recommendation> recommendations = integration.getRecommendations(productId);

    List<Review> reviews = integration.getReviews(productId);

    LOG.debug("getCompositeProduct: aggregate entity found for productId: {}", productId);

    return createProductAggregate(product, recommendations, reviews, serviceUtil.getServiceAddress());
  }

  @Override
  public void deleteProduct(int productId) {

    LOG.debug("deleteCompositeProduct: Deletes a product aggregate for productId: {}", productId);

    integration.deleteProduct(productId);

    integration.deleteRecommendations(productId);

    integration.deleteReviews(productId);

    LOG.debug("deleteCompositeProduct: aggregate entities deleted for productId: {}", productId);
  }

  private ProductAggregate createProductAggregate(
    Product product,
    List<Recommendation> recommendations,
    List<Review> reviews,
    String serviceAddress) {

    // 1. Setup product info
    int productId = product.getProductId();
    String name = product.getName();
    int weight = product.getWeight();

    // 2. Copy summary recommendation info, if available
    List<RecommendationSummary> recommendationSummaries = (recommendations == null) ? null :
      recommendations.stream()
        .map(r -> new RecommendationSummary(r.getRecommendationId(), r.getAuthor(), r.getRate(), r.getContent()))
        .collect(Collectors.toList());

    // 3. Copy summary review info, if available
    List<ReviewSummary> reviewSummaries = (reviews == null) ? null :
      reviews.stream()
        .map(r -> new ReviewSummary(r.getReviewId(), r.getAuthor(), r.getSubject(), r.getContent()))
        .collect(Collectors.toList());

    // 4. Create info regarding the involved microservices addresses
    String productAddress = product.getServiceAddress();
    String reviewAddress = (reviews != null && reviews.size() > 0) ? reviews.get(0).getServiceAddress() : "";
    String recommendationAddress = (recommendations != null && recommendations.size() > 0) ? recommendations.get(0).getServiceAddress() : "";
    ServiceAddresses serviceAddresses = new ServiceAddresses(serviceAddress, productAddress, reviewAddress, recommendationAddress);

    return new ProductAggregate(productId, name, weight, recommendationSummaries, reviewSummaries, serviceAddresses);
  }
}
----
====
Polar Book Shop::
+
[source, java]
----
----
======