= Containerize Spring Boot Using Docker
:figures: 16-deployment/packaging/docker

Cloud native applications are self-contained. Spring Boot lets you package your applications as standalone JARs, including everything they need to run except the runtime environment. That makes the containerization very straightforward, since all you need in a container image besides the JAR artifact is an operating system and a JRE.

== Packaging Spring Boot applications as container images

=== Containerizing Spring Boot with Dockerfiles
* build the JAR artifact for the service application. Open a Terminal window and navigate to the service project’s root folder. First, build the JAR artifact:
+
```bash
./gradlew clean bootJar
```
+
```bash
cd app-service
mvn clean package spring-boot:repackage
```
*  Open your Catalog Service project (catalog-service), and create an empty file
called Dockerfile (with no extension) in the root folder. That file will contain the rec-
ipe for containerizing your application.
+
[tabs]
====
Maven::
+
[,docker]
----
FROM openjdk:17

WORKDIR /workspace

ARG JAR_FILE=./target/*.jar

COPY ${JAR_FILE} catalog-service.jar

ENTRYPOINT ["java", "-jar", "catalog-service.jar"]
----

Gradle::
+
[,docker]
----
FROM openjdk:17

WORKDIR /workspace

ADD JAR_FILE=./build/libs/*.jar

COPY ${JAR_FILE} catalog-service.jar

ENTRYPOINT ["java", "-jar", "catalog-service.jar"]
----
====

* build the container image by running this command:for gradle
+
```bash
docker build -t catalog-service .
```
for maven
+
```bash
docker build --build-arg JAR_FILE=target/*.jar -t catalog-service .
```
* run the container image by running this command:  
+
```bash
docker run -d --name catalog-service -p 9001:9001 -p 8001:8001 app-service
```
* verify that the container is running by running this command:
+
```bash
docker ps
```
* verify that the application is running by opening a browser and navigating to
http://localhost:9001/catalog. You should see the catalog service’s home page.
* verify that the application is running by opening a browser and navigating to
http://localhost:8001/catalog/actuator/health. You should see the catalog service’s health status.

This simple approach has a few disadvantages:

* We are using the full JDK of Java SE 17, including compilers and other development tools. That makes the Docker images unnecessarily large and, from a security perspective, we don’t want to bring more tools into the image than necessary.
+
Regarding the lack of a Docker image for Java SE 17 JRE from the OpenJDK project, there are other
open source projects that package the OpenJDK binaries into Docker images. One of the most widely
used projects is Eclipse Temurin (https://adoptium.net/temurin/). The Temurin project provides
both full JDK editions and minimized JRE editions of their Docker images.
* The fat JAR file takes time to unpackage when the Docker container starts up. A better approach
is to instead unpackage the fat JAR when the Docker image is built.
* The fat JAR file is very big, as we will see below, some 20 MB. If we want to make repeatable
changes to the application code in the Docker images during development, this will result in
suboptimal usage of the Docker build command. Since Docker images are built in layers, we
will get one very big layer that needs to be replaced each time, even in the case where only a
single Java class is changed in the application code.
* A better approach is to divide the content into different layers, where files that do not change
so frequently are added in the first layer, and files that change the most are placed in the last
layer. This will result in good use of Docker’s caching mechanism for layers. For the first stable
layers that are not changed when some application code is changed, Docker will simply use
the cache instead of rebuilding them. This will result in faster builds of the microservices’
Docker images.
+
When it comes to handling the suboptimal packaging of fat JAR files in Docker images, Spring Boot
addressed this issue in v2.3.0, making it possible to extract the content of a fat JAR file into a number
of folders. see next section

=== Containerizing Spring Boot using layered-JAR mode

When building container images, you should consider performance at build time and
at run time. The layered architecture characterizing OCI images enables the caching
and reusing of unchanged layers when building an image. Container registries store images by layers, so that when you pull a new version, only the changed layers are
downloaded. That is quite an advantage in a cloud environment, considering the time
and bandwidth you'll save for all your application instances.

In the above dockerfile section, the standalone JAR file copied into a layer in the image. As a result, whenever you change something in your application,
the whole layer must be rebuilt. Consider the scenario where you just add a new REST
endpoint to your application. Even if all the Spring libraries and dependencies are
unchanged, and the only difference is in your own code, you must rebuild the whole
layer, since everything is together.

Spring Boot can package applications as JAR artifacts: the layered-JAR mode. which is the default mode, so you don't need any extra configuration to use the new functionality.

Applications packaged using the layered-JAR mode are made up of layers, similar to
how container images work. This new feature is excellent for building more efficient
images. When using the new JAR packaging, we can expand the JAR artifact and then
create a different image layer for each JAR layer. The goal is to have your own classes
(which change more frequently) on a separate layer from the project dependencies
(which change less frequently).
 By default, Spring Boot applications are packaged as JAR artifacts made up of the
following layers, starting from the lowest:

* dependencies--For all the main dependencies added to the project
* spring-boot-loader--For the classes used by the Spring Boot loader component
* snapshot-dependencies--For all the snapshot dependencies
* application--For your application classes and resources

We'll divide the work into two stages. In the first stage we extract the layers from
the JAR file. The second stage is where we place each JAR layer into a separate image layer. In the end, the result of the first stage is discarded (including the original JAR file), while the second stage will produce the final container image.

The Spring Boot documentation recommends creating one Docker layer for each folder in the order
listed above. After replacing the JDK-based Docker image with a JRE-based image and adding instructions for exploding the fat JAR file into proper layers in the Docker image, the Dockerfile looks like this:

[tabs]
====
Maven::
+
[,docker]
----
FROM eclipse-temurin:17.0.5_8-jre-focal AS builder

WORKDIR /workspace

ARG JAR_FILE=./target/*.jar

COPY ${JAR_FILE} catalog-service.jar

RUN java -Djarmode=layertools -jar catalog-service.jar extract

FROM eclipse-temurin:17.0.5_8-jre-focal

RUN useradd spring

USER spring

WORKDIR /workspace

COPY --from=builder workspace/dependencies/ ./
COPY --from=builder workspace/spring-boot-loader/ ./
COPY --from=builder workspace/snapshot-dependencies/ ./
COPY --from=builder workspace/application/ ./

ENTRYPOINT ["java", "org.springframework.boot.loader.JarLauncher"]
----

Gradle::
+
[source, gradle]
----
FROM eclipse-temurin:17.0.5_8-jre-focal as builder
WORKDIR extracted
ADD ./build/libs/*.jar app.jar
RUN java -Djarmode=layertools -jar app.jar extract

FROM eclipse-temurin:17.0.5_8-jre-focal
WORKDIR application
COPY --from=builder extracted/dependencies/ ./
COPY --from=builder extracted/spring-boot-loader/ ./
COPY --from=builder extracted/snapshot-dependencies/ ./
COPY --from=builder extracted/application/ ./

EXPOSE 8080

ENTRYPOINT ["java", "org.springframework.boot.loader.JarLauncher"]
----
====
+
To handle the extraction of the fat JAR file in the Dockerfile we use a multi-stage build, meaning that
there is a first step, named builder, that handles the extraction. The second stage builds the actual
Docker image that will be used at runtime, picking the files as required from the first stage. Using this
technique, we can handle all packaging logic in the Dockerfile but, at the same time, keep the size of
the final Docker image to a minimum:
+
1. The first stage starts with the line:
FROM eclipse-temurin:17.0.5_8-jre-focal as builder
From this line, we can see that a Docker image from the Temurin project is used and that it
contains Java SE JRE for v17.0.5_8. We can also see that the stage is named builder.
2. The builder stage sets the working directory to extracted and adds the fat JAR file from the
Gradle build library, build/libs, to that folder.
3. The builder stage then runs the command java -Djarmode=layertools -jar app.jar
extract, which will perform the extraction of the fat JAR file into its working directory, the
extracted folder.
4. The next and final stage starts with the line:
[source,yml,attributes]
----
FROM eclipse-temurin:17.0.5_8-jre-focal
----
+
It uses the same base Docker image as in the first stage, and the application folder as its
working directory. It copies the exploded files from the builder stage, folder by folder, into
the application folder. This creates one layer per folder, as described above. The parameter
--from=builder is used to instruct Docker to pick the files from the file system in the builder
stage.
5. After exposing the proper ports, 8080 in this case, the Dockerfile wraps up by telling Docker what
Java class to run to start the microservice in the exploded format, that is, `org.springframework.boot.loader.JarLauncher`.

=== Building a Docker image
To build the Docker image, we first need to build our deployment artifact (that is, the fat JAR file) for
product-service:

[source,bash,attributes]
----
./gradlew :microservices:product-service:build
----
We can find the fat JAR file in the Gradle build library, build/libs
ls -l microservices/productservice/build/libs 

you can view its actual content by using the 

unzip -l microservices/product-service/build/libs/product-service-1.0.0-SNAPSHOT.jar

we can build the Docker image and name it product-service, as follows:

docker build -t product-service .

Docker will use the Dockerfile in the current directory to build Docker Engine. The image will be
tagged with the name product-service and stored locally inside the Docker engine

Verify that we got a Docker image, as expected, by using the following command:

docker images | grep product-service

== Using Docker Compose to manage the container life cycle

[,yml]
----
services:
  catalog-service:
    depends_on:
      - polar-postgres
    image: "catalog-service"
    container_name: "catalog-service"
    ports:
      - 9001:9001
      - 8001:8001
    environment:
      # Buildpacks environment variable to configure the number of threads in memory calculation
      - BPL_JVM_THREAD_COUNT=50
      # Buildpacks environment variable to enable debug through a socket on port 8001
      - BPL_DEBUG_ENABLED=true
      - BPL_DEBUG_PORT=8001
      - SPRING_CLOUD_CONFIG_URI=http://config-service:8888
      - SPRING_DATASOURCE_URL=jdbc:postgresql://polar-postgres:5432/polardb_catalog
      - SPRING_PROFILES_ACTIVE=testdata

  config-service:
    image: "config-service"
    container_name: "config-service"
    ports:
      - 8888:8888
      - 9888:9888
    environment:
      # Buildpacks environment variable to configure the number of threads in memory calculation
      - BPL_JVM_THREAD_COUNT=50
      # Buildpacks environment variable to enable debug through a socket on port 9888
      - BPL_DEBUG_ENABLED=true
      - BPL_DEBUG_PORT=9888

  # Backing Services

  polar-postgres:
    image: "postgres"
    container_name: "polar-postgres"
    ports:
      - 5432:5432
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=polardb_catalog
----

* BPL_JVM_THREAD_COUNT environment variable is used to configure the number of threads memory should be allocated for in the JVM stack

run the following command to start the containers in detached mode:

`docker-compose up -d`
