= Communication Patterns
:figures: 01-system-design/communication-patterns

A summary of how you can combine patterns and tools. Keep in mind
that this is just a recommendation. you might have your own
preferences to implement these patterns using different tooling.

|===
| Pattern | Type | Implementation

| Request/response
| Synchronous
| REST API

| Commands that require blocking
| Synchronous
| REST API

| Commands that don't require blocking
| Asynchronous
| Message broker

| Events
| Asynchronous
| Message broker
|===

It's worth noting that, even though the end-to-end communication can be
asynchronous, you'll get a synchronous interface with the message broker from your
applications. That's an important characteristic. When you publish a message, you
want to be sure the broker received it before continuing with something else. The same
applies to subscribers, where the broker requires acknowledgment after consuming
messages to mark them as processed and move to the next ones. These two steps
are critical to keep your data safe and make your system reliable.

== Synchronous communication

== Asynchronous communication

=== REST API calls with retry pattern
Options to model the exchange between two applications

* Create a shared library—One option is to create a shared library with the classes used
by both applications, and import it as a dependency into both projects. As per the
15-factor methodology, such a library would be tracked in its own codebase. Doing
so would ensure that the model used by both applications is consistent and never
out of sync. However, it would mean adding implementation coupling.
* Duplicate the class—The other option is to replicate the class into the upstream
application. By doing so, you wouldn’t have implementation coupling, but
you would have to take care of evolving the replicated model as the original
one changes in the downstream application. There are a few techniques like
consumer-driven contracts that can identify, through automated tests, when the
called API changes. Besides checking the data model, those tests would also verify other aspects of the exposed API, like HTTP methods, response statuses,
headers, variables, and so on, check the Spring Cloud Contract project if you’re interested (https://
spring.io/projects/spring-cloud-contract).

Both are viable options. Which strategy you adopt is up to your project requirements and your organization’s structure. 

=== Event-driven Architecture

== Reactive Systems

== Choosing between non-blocking synchronous APIs and event-driven asynchronous services

When developing reactive microservices, it is not always obvious when to use non-blocking synchronous APIs and when to use event-driven asynchronous services. In general, to make a microservice 
robust and scalable, it is important to make it as autonomous as possible, for example, by minimizing 
its runtime dependencies. This is also known as loose coupling. Therefore, the asynchronous message passing of events is preferable over synchronous APIs. This is because the microservice will only 
depend on access to the messaging system at runtime, instead of being dependent on synchronous 
access to a number of other microservices.
There are, however, a number of cases where synchronous APIs could be favorable. For example:

* For read operations where an end user is waiting for a response
* Where the client platforms are more suitable for consuming synchronous APIs, for example, mobile apps or SPA web applications
* Where the clients will connect to the service from other organizations – where it might be hard to agree on a common messaging system to use across organizations

[tabs]
======
CaveatEmptor::
+

Cities API::
+

Multiplication microservices::
+

Microservices with Spring Boot 3 and Spring Cloud::
+
However, one major concern was identified . Updating (creating or deleting) a composite 
entity—an entity whose parts are stored in a number of microservices—using synchronous APIs can 
lead to inconsistencies, if not all involved microservices are updated successfully. This is, in general, 
not acceptable. This leads us into reactive microservices, where we will look into why and how to build 
reactive microservices, that is, microservices that are scalable and robust.
+
For the system landscape in this book, we will use the following:
+
* The create, read, and delete services exposed by the product composite microservice will be 
based on non-blocking synchronous APIs. The composite microservice is assumed to have 
clients on both web and mobile platforms, as well as clients coming from other organizations 
rather than the ones that operate the system landscape. Therefore, synchronous APIs seem 
like a natural match.
* The read services provided by the core microservices will also be developed as non-blocking 
synchronous APIs since there is an end user waiting for their responses.
* The create and delete services provided by the core microservices will be developed as 
event-driven asynchronous services, meaning that they will listen for create and delete events 
on topics dedicated to each microservice.
* The synchronous APIs provided by the composite microservices to create and delete aggregated 
product information will publish create and delete events on these topics. If the publish operation succeeds, it will return with a 202 (Accepted) response; otherwise, an error response will 
be returned. The 202 response differs from a normal 200 (OK) response – it indicates that the 
request has been accepted, but not fully processed. Instead, the processing will be completed 
asynchronously and independently of the 202 response.
+
images::{figures}/Microservices-with-Spring-Boot-and-Spring-Cloud-communication-pattern.png

Polar Book Shop::
+

======